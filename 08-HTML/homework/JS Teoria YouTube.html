<!DOCTYPE html>
<html lang="es">

  <head>
    <meta charset="UTF-8">
    <title>Teoría YouTube JavaScript - Marina Aguirre</title>
  </head>

    <body> 
      <div class="divClassDescripcionPersonal">
        <h1>Teoría YouTube JavaScript</h1>
        <h3>Resúmen</h3>    
        
        <script>
          var hola = "Hola, soy Marina.";
          let hello = "Hello, I'm Marina."
          console.log(hola);
          console.log(hello);
          // Esto es un bloque. Comentario de 1 líneas
          /* 
          Esto es 
          un comentario
          de varias líneas
          */
          let musica2 = "Rock";
          console.log("Variable Música antes del Bloque.", musica2);
          {
            let musica2 = "Pop";
            console.log("Variable Música dentro del Bloque.", musica2);
          }
          console.log("Variable Música después del Bloque", musica2);

          // objeto:
          const objeto = {
            nombre: "Marina",
            edad: 35,
          }

          // arreglos:
          const color = ["blanco","negro", "azul"];
          console.log(objeto);
          console.log(color);

          objeto.correo = "maguirre.neticel@gmail.com";
          color.push("anaranjado");

          console.log(objeto);
          console.log(color);

          // Cadenas de texto o Strings
          let nombre = "Marina";
          let apellido = "Aguirre";
          let saludo9 = new String("Hola, esto es un saludo9");
          console.log(nombre, apellido, saludo9);
          console.log(
            nombre.length,
            apellido.length,
            saludo9.length,
          );


            // Concatenación

          let saludo = "Hola mi nombre es " + nombre + " " + apellido + "."
          console.log(saludo)

          // Interpolación de Variables
          // Template String

          let saludo2 =`Hello my name is ${nombre} ${apellido}.`;
          console.log(saludo2)

          // Generación dinámica SIN Template String
          // Opción mala, tediosa
          // NO SE VE BIEN EN LA CONSOLA:

          let ul = "<ul><li>Primavera</li><li>Verano</li><li>Otoño</li><li>Invierno</li></ul>";
          console.log(ul)

          // Template String: 

          let ul2 = `
          <ul>
            <li>Primavera</li>
            <li>Verano</li>
            <li>Otoño</li>
            <li>Invierno</li>
          </ul>
          `;
          console.log(ul2)

          // Otra opción mala y tediosa 
          // QUE NO SE VE BIEN EN LA CONSOLA:

          let ul3 = "<ul>";
            ul3 += "<li>Primavera</li>";
            ul3 += "<li>Verano</li>";
            ul3 += "<li>Otoño</li>";
            ul3 += "<li>Invierno</li>";
            ul3 += "</ul>";
          
          console.log(ul3)

          let lorem = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.";
          console.log(
            nombre.length,
            apellido.length,
            saludo.length,
            nombre.toUpperCase(),
            apellido.toLowerCase(),
            lorem.includes("amet"),
            lorem.includes("Marina"),
            lorem.trim(),
            lorem.split(' '),
            lorem.split(","),
          )
          
          let a = 12;
          let b = new Number (07);

          console.log(a,b)

          /*
          UNA FUNCIÓN ES UN BLOQUE DE CÓDIGO, AUTOCONTENIDO, 
          QUE SE PUEDE DEFINIR UNA VEZ Y EJECUTAR EN CUALQUIER
          MOMENTO. OPCIONALMENTE UNA FUNCIÓN PUEDE ACEPTAR
          PARÁMETROS Y DEVOLVER UN VALOR.
          LAN FUNCIONES EN JAVASCRIPT UN TIPO ESPECIAL DE 
          OPBETOS.
          SON CIUDADANOS DE PRIMERA CLASE. PORQUE PUEDEN
          ASIGNARSE A UN VALOR, PASARSE COMO ARGUMENTOS Y
          USARSE COMO VALOR DE RETORNO.
          */

          // DECLARADACIÓN DE FUNCIÓN
          function estoEsUnaFuncion() {
            console.log("Unos");
            console.log("Dos");
          }
          //INVOCACIÓN DE FUNCIÓN
          estoEsUnaFuncion();
          estoEsUnaFuncion();
          estoEsUnaFuncion();
          estoEsUnaFuncion();


          function unaFuncionQueDevuelveValor(){
            console.log("ValorA");
            console.log("ValorB");
            //return 1976;// Si ingresamos un return acá,
            //no se ejecuta el resto del código//
            return "La funcion retorna un String";
          }

          let valorFuncion = unaFuncionQueDevuelveValor();
          console.log(valorFuncion);

          function saludar (nombre = "Desconocido", edad = 0){
            console.log(`Hola mi nombre es ${nombre} y tengo ${edad}.`);
          }

          saludar("Luna",12);
          saludar (); 
          /*Al no tener NINGÚN VALOR ASIGNADO AL INVOCAR LA función se muestran
           los datos cragados por defecto*/
                     
           // FUNCIONES DECLARADAS VS. FUNCIONES EXPRESADAS

           function funcionDeclarada(){
           console.log("Función DECLARADA, que puede invocarse en cualquier parte del código, incluse antes de que la función sea declarada.")
           }
           funcionDeclarada();

           /* Cuando en Javascript se declara una función
           DECLARATIVA (como arriba), JavaScript hará un
           Hoisting de la función. O sea que la ordenará,
           la ELEVARÁ al siguiente ambito superior.
           *** El concepto de Hoisting fue pensado como una
           manera general de referirse a cómo funcionan los
           contextos de ejecución en JavaScript ***
           */

          
           // FUNCIÓN ANÓNIMA:
        
           const funcionExpresada = function(){
            console.log("Esto es una función EXPRESADA.Que no PODEMOS invocar antes de su declaración.");
           }
           funcionExpresada();

           /* "Esto es una función EXPRESADA.Que se le asignó como
           valor a una variable. Si la invocamos antes de su 
           definición JavaScript nos dirá... 
           Uncaught ReferenceError: Cannot access 
           'funcionExpresada' before initialization";
           */

           /*AHORA VAMOS A VER VALORES COMPUESTOS: 
           object = {}
           array = []
           function () {}
           Class {}
           etc.
           */

           // ARREGLOS / ARRAYS
           // podemos declararlos con Const o con Let.

           const d =[];
           const x =[1,true,"Marina","A","B",["Flora","Lunita"]];
           console.log(d);
           console.log(x);
           console.log(d.length);
           console.log(x[2]);
           console.log(x[5][1]);

           // Un nuevo método para crear ARRAYS/ARREGLOS
           // desde 2015. ECMAScript 6. MÉTODO ARRAY.OF

           const f = Array.of("X","Y",6,7,8);
           console.log(f);

           // Crear un ARREGLO con Array fill()

           const g = Array(100).fill(false);
           console.log(g);

           // NO SE USA YA ESTA FORMA DE CREAR ARRAYS/ARREGLOS:

           const h = new Array(); // NO SE USA MÁS ES VIEJO
           console.log(h);

           const i = new Array(1,2,3, true, false);
           console.log(i);

           // MÉTODOS PUSH Y POP EN ARREGLOS:

           const colors = ["Rojo", "Verde", "Azul"];
           console.log (colors);

           colors.push("Amarillo"); // Agrega el color amariollo al final del arreglo.
           console.log(colors);

           colors.pop();   // Elimina el último elemento del Arreglo
           console.log(colors);

           colors.forEach(function(element, index){    // elemento + index
            console.log(`<li id="${index}">${element}</li>`);
           });

           /* 
           OBJETOS
           En JavaScript se dice que TODO ES UN OBJETO.
           Un OBJETO es una colección de key/values (llaves/valores)
           Podemos inic ializar un OBJETO con el constructor new.
           */

           let ab = new String("Hola");
           console.log(ab);

           //DECLARAMOS UN OBJETO con "const"
           const bc = {
            // OBJETO VACÍO
           }
           console.log(bc);

           // DECLARAR UN OBJETO CON prototypo OBJECT
           // QUE YA CASI NADIE LO USA
           const c = new Object();
           console.log(c);
           // QUE YA CASI NADIE LO USA

           // Cración de 1 Objeto con arrays incluidos:

           
       const luciano = {
            Nombre: "Luciano",
            Apellido: "Burgarelli",
            Edad: 39,
            Profesion: "Medico",
            Especialidad: "Cirujano Cardiotorácico",
            Pasatiempo: ["Viajar a China", "Comer insectos", "Jugar a operar"],
            Soltero: false,
            Contacto: {
                email: "luciano@gmail.com",
                movil: "5493512463385",
            },
            saludar: function (){
             console.log("Hola :)")   
            },
            decirMiNombre: function (){
              console.log(`Hola, soy el Dr. ${this.Nombre} ${this.Apellido} y tengo ${this.Edad} años`)
            }
           }
           console.log(luciano);


           //¿Cómo ACCEDER a los ATRIBUTOS/PROPIEDADES (variables) de los OBJETOS?
           // Así: 

           console.log(luciano["Nombre"]);   //Notación de corchetes para acceder
           console.log(luciano["Apellido"]); //Notación de corchetes para acceder
           console.log(luciano.Pasatiempo); // Notación de Puntos.
           console.log(luciano.Pasatiempo[2]);  // Notación de Puntos Para acceder al SEGUNDO PASATIEMPO.
           console.log(luciano.Nombre);     // Notación de Puntos.
           console.log(luciano.Contacto.email);  

           //¿Cómo ACCEDER a los MÉTODOS (FUNCIONES) de los OBJETOS?
           // Así: 
           luciano.saludar();
           luciano.decirMiNombre();

           /* Cómo listar con el MÉTODO KEYS de Object:

           Se pueden enlistar las Keys (llaves) de un
           Objeto en forma de ARREGLO/ARRAY. 
           Abajo se enlistan las 8 keys del "Objeto Marina" */ 
           console.log(Object.keys(luciano));


           /* Cómo listar con el MÉTODO VALUES de Object:
           Se pueden enlistar los VALUES (VALORES) de un
           Objeto en forma de ARREGLO/ARRAY. */
           console.log(Object.values(luciano));


            /* Cómo saber si un Object tiene alguna
            PROPIEDAD ESPECÍFICA?
           Con este MÉTODO DE Object se puede saber eso.*/
           console.log(luciano.hasOwnProperty("Nombre"));

    /* OPERADORES */
    /* OPERADORES ARITMÉTICOS:
    Suma +    Divición /          Módulo % 
    Resta-    Multiplicación*     Agrupación()     
    */
    let ejercicio = 5 + 5 - 10 * 3
    let ejercicio2 = 5 + (5 - 10) * 3
    let modulo = 5 % 2; // Operador aritmético MÓDULO
                         // DEVUELVE EL RESUDUO DE 1 División.  
    console.log(ejercicio);
    console.log(ejercicio2);
    console.log(modulo);

    /* OPERADORES RELACIONALES:
    >, <, >=, <=, ==, ===, !=, !==
    */

    console.log(8 > 9);   // False
    console.log(9 > 8);   // True
    console.log(9 >= 8);  // True
    console.log(7 < 7);   // False
    console.log(7 <= 7);  // True
         
    /*
    =    1 igual es asignación de VARIABLE
    ==   2 iguales es COMPARACIÓN de VALORES. MALA PRÁCTICA
    ===  3 iguales COMPARA VALORES Y TIPO DE DATO
         posee "IGUALDAD ESTRICTA".
    */
    console.log(7 == 7);     // True son el mismo valor,7.
    console.log("7" == 7);   // True tienen el mismo valor, 7.
    console.log(0 === false) // False

    console.log(7 === 7);    // True son el mismo valor,7.
    console.log("7" === 7);  // False. Son tipos de datos distintos.
    console.log(0 === false) // False

    /* OPERADORES de INCREMENTO Y DECREMENTO
    let incremento = 2;
    console.log(incremento ++); // A incremento le suma 1.
    console.log(incremento);   // Incremento vale 3 ahora.   
    console.log(++incremento); // LÑe suma 1 a Incremento que ya vale 4. Total 4

    // incremento = incremento + 2;
    // incremento += 3;

    // OPERADOR UNARIO: Le suma 1 a nuestra VARIABLE "INCREMENTO"
    incremento ++;  
    incremento --;  
    ++incremento;
    --incremento;*/

    /* OPERADORES LÓGICOS: 
    || Or: cuando tenemos 2 Condiciones, con que 1 sea
       VERDADERA el Operador "OR" se ejecutará, validando.
    ! Not: Niega. Lo que es VERDADERO lo convierte en FALSO.
    && AND LÓGICO: Para que sean validadas como VERDADERA, 
      Deben cumplirse todas las condiciones para que AND se ejecute.
    */

    console.log(!true);
    console.log(!false);
    console.log(9 === 9 || "9" === 9); // Es TRUE porque la primera condición es VERDADERA.

/* ESTRUCTURAS DE CONTROL:
Todas las líneas de código que escribimos hasta ahora
fueron "Estructuras Secuenciales".
- ESTRUCTURAS SECUENCIALES (van una detrás de la otra)
- ESTRUCTURAS CONDICIONALES.
- LOOPS (Estructuras repetitivas). */  

// - ESTRUCTURAS CONDICIONALES: IF ELSE. Estructura de
// programación que me permite tomar una decición si
// una condición se cumple.

let edad = 19;

if(edad > 17){
  console.log("Eres mayor de edad");
} else {
  console.log("Eres menor de edad");
}

if(edad >= 18){
  console.log("Eres mayor de edad");
} else {
  console.log("Eres menor de edad");
}

/* IF-ELSE IF - ELSE

Dejame dormir 00hs - 5hs 
Buenos días 6hs - 11hs
Buenas tardes 12hs - 19hs
Buenas noches 20hs - 23hs  */

let hora = 20;

if (hora >= 0 && hora <= 5){
  console.log("Dejame dormir");
} else if (hora >= 6 && hora <= 11) {
  console.log("Buenos días");
} else if  (hora >= 12 && hora <= 19) {
  console.log("Buenas tardes");
} else {
  console.log("Buenas noches");
}


/* OPERADOR TERNARIO (Simplifica el If Else)
(Condición) ? verdadero : falsa
Tiene una condición que va entre paréntesis ()
si se cumple la condición y es VERDADERO sigue 
un signo de INTERROGACIÓN ? y la línea de código
a EJECUTAR.
Luego : y la línea de código a ajecutar si la
condición es FALSA.
 */

 console.log("Operador Ternario");
 let eresMayor = (edad >= 18)  // Condición.
 ? "Eres mayor de edad"   //Ejecución si es VERDADERO.
 : "Eres menor de edad";  //Ejecución si es FALSO.   
 console.log(eresMayor);

 /*  SWITCH CASE:
Para evaluar diferentes VALORES para una misma variables.
Por ejemplo en estyos casos: DOMINGO: 0, LUNES:1, 
MARTES:2, MIERCOLES: 3, JUEVES:4, VIERNES:5, SÁBADO: 6.
 */

let dia = 4;

 switch (dia) {
  case 0:
    console.log("Es Domingo")  // Es lo que se ejecutará si se cumple esta condición.
    break;
  case 1:
    console.log("Es Lunes")  // Es lo que se ejecutará si se cumple esta condición.
    break;
  case 2:
    console.log("Es Martes")  // Es lo que se ejecutará si se cumple esta condición.
    break;
  case 3:
    console.log("Es Miercoles")  // Es lo que se ejecutará si se cumple esta condición.
    break;
  case 4:
    console.log("Es Jueves")  // Es lo que se ejecutará si se cumple esta condición.
    break;
  case 5:
    console.log("Es Viernes")  // Es lo que se ejecutará si se cumple esta condición.
    break;
  case 6:
    console.log("Es Sábado")  // Es lo que se ejecutará si se cumple esta condición.
    break;

  default:
    console.log("Ingrese un día entre 0 y 6")
    break;
 }


 /*  CICLOS LOOPS:
WHILE Y DO WHILE  // YA NO SE USA TANTO ULTIMAMENTE.
En el "While", antes de comenzar a EJECUTAR la línea
de codigo indicada, la CONDICIÓN se debe cumplir.
En el "DO WHILE" siempre se ejecuta el cloque de
código dentro de las llaves {} del do.
Y luego realiza la COMPARACIÓN de la condición. */

 let contador = 0;

 while (contador < 10) {
  console.log("while " + contador);
  contador ++;
 }

 let contador2 = 0;
 do {
  console.log("do while " + contador2)
  contador2 ++;
 } while (contador2 < 10);

/* BUCLE FOR 
Es el más empleado. Es una estructura de 3 partes:
a) Inicialización de la Variable; 
b) Condición a evaluar;
c) Decremento o incremento
Luego las sentencias que ejecuta el Bucle FOR.

for (inicializacion; condición; decremento o incremento) {
  sentencias que ejecuta el for;
  sentencias que ejecuta el for;
  sentencias que ejecuta el for;
} */

for (let i = 0; i < 10; i++) {
  console.log("for " + i);  
}

let numeros = [10, 20, 30, 40, 50];

for (let i = 0; i < numeros.length; i++) {
  console.log(numeros[i])
}

/* BUCLE FOR IN: 
Permite recorrer las propiedades (key) de un OBJETO.
for (const key in object) {
  if (Object.hasOwnProperty.call(object, key)) {
    const element = object[key];
*/
const andrea = {
  Nombre: "Andrea",
  Apellido: "Rios de Aguirre",
  Edad: 46,
}

for (const propiedad in andrea){
  console.log(`key: ${propiedad}, Value: ${andrea[propiedad]}`);
  // Para acceder a una propiedad en un OBJETO,
  // debemos emplear la notación de corchetes [].
}

/* BUCLE FOR OF: 
Nos permite recorrer las propiedades de TODOS
LOS ELEMENTOS ITERABLES: ARRAYS, OBJETOS, CLASES,
STRING (CADENA DE TEXTOS).
for (const iterator of object) {
  acá va el código de ejecución
}
*/

let numeros2 = [60, 70, 80, 90];
for (const elemento of numeros2) {
  console.log(elemento);
}

let string = "Argentina Campeón";

for (const caracter of string) {
  console.log(caracter);
}

/* ESTRUCTURA DE CONTROL PARA EL

::: MANEJO/DETECCCIÓN DE ERRORES :::
Esta es la forma de EVALUAR tu código
ordenadamente: "Try catch finally". Sintaxis así:

try {
 acá vá el código a evaluar 
} catch (error) {
  acá va el código a mostrar sobre el error
}

*/

try {
  console.log("Acá se agrega el código a evaluar")
  variableInexistente;
  console.log("Segundo mensaje en try")
} catch (error) {
  console.log("Catch capturó un error emanado del try")
  console.log(error);
} finally {
  console.log("El bloque finally se ejecutará al final de un bloque try-catch")
}

// PERSONALIZAR NUESTROS MENSAJES CUANDO
// SURGE UN ERROR.

try {
  let numero = "Y";

  if (isNaN(numero)) {
   throw new Error("El caracter no es un Número");
  }

  console.log(numero*numero);
} catch(error){
  console.log(`Se produjo el siguiente error: ${error}`);
}

/* 
 ESTRUCTURA DE CONTROL
 SENTENCIAS "BREAK" & "CONTINUE"
 para controlar las estructuras de control como por
 ejemplo en un loop.
 Con estas sentencias nos "salimos" del bucle.
 Son importantes para EVITAR el bucle infinito.
*/

// EJEMPLO DE "BREAK": Rompe la iteración del bucle/ciclo.
// según la condición sea cumplida.
// Se usa por ejemplo para imprimir sólo numeros pares o impares.

const numeros3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];

for (let i = 0; i < numeros3.length; i++) {
  if (i === 5){ // Condicional: Cuando la variable i llegue a 5
    break;  // Se produce el break => se sale del bucle for.
  }
  console.log(numeros3[i]);  //Recorremos los elementos del arreglo, en la posición "i".
}

// EJEMPLO DE "CONTINUE": Omite mostrar el código en esa iteración del bucle for.

const numeros4 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];

for (let i = 0; i < numeros4.length; i++) {
  if (i === 5){ // Condicional: Cuando la variable i llegue a 5
    continue;  // Omite mostrar la posición 6 de "i".
               // Y continua con el ciclo dfel bucle for desde el 7 en adelante.
  }
  console.log(numeros4[i]);  //Recorremos los elementos del arreglo, en la posición "i".
}

/* DESTRUCTURACIÓN:
Una nueva forma de asignar VALORES a OBJETOS y ARRAYS.
Em librerias como Angular, React o Viuw se emplea esta sintaxis
para asignar DINÁMICAMENTE lo que viene en un Arreglo u Objeto.
de manera ágil.
*/
const numeros6 = [1, 2, 3];

// SIN destructuración: Se asignan en variables
// independientes los valores que posee el Arreglo
let uno = numeros6[0];
    dos = numeros6[1];
    tres = numeros6[2];

    console.log(uno, dos, tres);

// CON destructuración:
const [one, two, three] = numeros6;
console.log(one, two, three);

// DESTRUCTURACIÓN EN OBJETOS en VARIABLES SEPARADAS:

const perruno = {
  Nombre1: "Luna",
  Apellido1: "Rios Aguirre",
  Edad1: 12
}

let {Nombre1, Apellido1, Edad1} = perruno;
console.log(Nombre1, Apellido1, Edad1);

/* OBJETOS LITERALES:
ES UNA NUEVA FORMA DE ESCRIBIR ATRIBUTOS & MÉTODOS
Y ASIGNARLOS.*/

let nombre2 = "Manchita";
edad2 = 19;

const perra = {
  nombre2: nombre2,
  edad2:edad2,
  ladrar: function () {
    console.log("Guauu guauuu!")
  }
}
console.log(perra)
perra.ladrar()


// NUEVA FORMA DE DECLARAR MÉTODOS EN
// OBJETOS LITERALES en ECMAscript 6.
const dog = {
  nombre2,
  edad2,
  raza: "Puro perro",
  ladrar (){
   console.log("Guau guau guau!")
  } 
}

console.log(dog);
dog.ladrar()

/* PARÁMETROS "REST" y "OPERADOR SPREAD"
"REST": Son una forma de ir agregando
PARÁMETROS en una "FUNCION" o "VARIABLE" 
cuando no sabemos de antemano cuántos valores
recibiremos en esa función. Se inician con ""...""
"OPERADOR SPREAD" (operador de propagación): 
Cuando tengamos que expandir una expresión donde
haya que almacenar multipleas argumentos o elementos, 
podamos hacerlo.
  */

// Parámetros "rest" para framework como
// REACT y librerías reactivas.

  function sumar(a, b, ...c) {   // a,b y c son PARÁMETROS que recibe una función.
    let resultado = a + b;

    c.forEach(function(numero) {
      resultado += numero
    });
    return resultado;
  }
  console.log(sumar(1,2));
  console.log(sumar(1,2,3));
  console.log(sumar(1,2,3,4,5));
 
//"OPERADOR SPREAD": Se puede ejecutar en cualquier
//sentencia de nuetro código. Se copian los
//anteriores parámetros y se agragan nuevos.

const arrayA = [1,2,3,4,5];  //Acá hay 5 valores.
  arrayB = [6,7,8,9,0];      //Acá hay 5 valores.

  console.log(arrayA, arrayB);

//Si debemos crear un tercer array a partir
//de los 2 array anteriores (A y B). Hacemos así:

const arrayC = [...arrayA, ...arrayB]
console.log(arrayC); //Acá se crea un nuevo array
                     //con 10 valores juntos.
  
/* ARROW FUNCTION: 
Un nueva forma de declarar una FUNCIÓN ANÓNIMA.
* Un FUNCIÓN EXPRESADA (function expression) es
cuando a una VARIABLE le asignás el VALOR de 
una "Función Anónima".
*/
// EJEMPLO FUNCIÓN ANÓNIMA:
const saludando = function () {
  console.log("Hola, función anónima");
}
saludando();

// EJEMPLO FUNCION DECLARADA:
function saludando1 () {
  console.log("Hola, función declarada");
}
saludando1();

// EJEMPLO ARROW FUNCTION:
// Omitimos las llaves si hay sólo 1 línea de código.
const saludando2 = () => console.log("Hola, ARROW FUNCTION");
saludando2()

// EJEMPLO recibir PARÁMETROS con ARROW FUNCTION:
const saludando3 = nombre3 => console.log(`Hola, ${nombre3}`);
saludando3("Irma"); // Recibe el parámetro del nombre Irma


/////////////////////////////////////

// EJEMPLO FUNCIÓN ANÓNIMA en SUMA:
const sumar2 = function (a, b) {
  return a + b;
}
console.log(sumar2(62, 44));


// EJEMPLO FUNCIÓN ANÓNIMA con ARROW FUNCTIONS:
// Omitimos las llaves si hay sólo 1 línea de código.
// Si hay más de un parámetro se colocan entre paréntesis ().
const sumar3 = (a,b) => a + b;  // Omitimos las llaves si hay sólo 1 línea de código.
console.log(sumar3(12, 76));


// EJEMPLO ARROW FUNCTION con varias líneas:
// Se incluyen las llaves.
const funcionDeVariasLineas = () => {
  console.log("Primera línea de Código");
  console.log("Segunda línea de Código");
  console.log("Tercera línea de Código");
}
funcionDeVariasLineas(); // Ejecutamos la función "funcionDeVariasLineas"


//Ejemplo de ARREGLOS con FOR EACHS:
const numeros7 = [1,2,3,4,5];

numeros7.forEach(function (elemento, index) {
  console.log(`El elemento ${elemento} está en la posición ${index}`);
})

//Ejemplo de ARREGLOS con ARROW FUNCTIONS:

const numeros8 = [1,2,3,4,5,6];

numeros8.forEach((elemento, index) => console.log(`${elemento} está en la posición ${index}`));

/* En JavaScript hay CONTEXTOS: GLOBALES, 
EN FUNCIONES, EN OBJETOS, EN BLOQUES {}.  
Las ARROW FUNCTIONS capturan el OBJETO this
(la palabra reservada "THIS") del contexto en el que 
se encuentren.
*/

// Ejemplo de FUNCIÓN DECLARADA: Perro
function Perro() {
  console.log(this); // Acá THIS se vuelve el Objeto Window.
                     //Porque la función existe dentro del contexto global del Navegador.
}
Perro(); // Ejecutamos la función PERRO.


// Ejemplo de Objeto Perro con una FUNCIÓN ANÓNIMA NORMAL.
// Donde THIS en este contexto es perro2.
// RESPETA EL CONTEXTO DONDE SE ENCUENTRA.
const perro2 = {
  nombre: "Gringo",
  ladrar2: function (){
    console.log(this) //En este contexto this hace referencia al Objeto perro2.
  }
}
perro2.ladrar2();

/* Ejemplo de Objeto con ARROW FUNCTIONS:
El contexto de THIS acá es el global: Windows.
Las Arrow functions se "saltan" el contexto en el que están
y heredan o reconocen el contexto "padre / parent" global donde se declararon.*/

// OBJETOS LITERALES:
const perro3 = {
  nombre: "Bobby",
  ladrar3 () {
    console.log(this) //En este contexto this hace referencia a WINDOWS.
  }
}
perro3.ladrar3();

/*  DENTRO DE UN OBJETO LITERAL, no es una
buena práctica CREAR UN método A PARTIR DE UNA 
ARROW FUNCTIONS. 
HAY QUE TENER CUIDADO AL EMPLEAR arrow function 
EN FUNCIONES CLÁSICAS.*/

/*
PROTOTIPOS /PROTOTYPE:
En JavaScript la programación está ORIENTADA A OBJETOS
Es un mecanismo por el cual un OBJETO puede heredar 
de un objeto "padre" ATRIBUTOS (Variables) 
y MÉTODOS (funciones).
La herencia deviene de la CADENA DE PROTOTIPOS.
El PROTOTIPO hace una COPIA del objeto padre.

POO (Programación Orientada a Objetos)

+ CLASES:  Modelo a seguir. Nos sirve de esquema, plantilla
para basarnos y generar INSTANCIAS de una CLASE.

+ OBJETOS: Es una INSTANCIA de una CLASE. Y posee 2 facultades:
 - ATRIBUTOS: Característica o propiedad del OBJETO. 
   Son VARIABLES dentro de un OBJETO.
 - MÉTODOS: Son las acciones que un OBJETO puede realizar.
            Son FUNCIONES dentro del OBJETO.
            Por lo generar son verbos que terminan en acciones. 
*/

// OBJETOS LITERALES:
const animal = {
  nombre: "El Rey León",
  rugido(){
    console.log("Me encanta producir rugidos.");
  }
}

console.log(animal);

// Luego podría COPIAR y PEGAR otro objeto.
// Pero esto no es funcional.

// OBJETOS LITERALES:
const animal2 = {
  nombre: "Snoopy",
  ladridos(){
    console.log("Me encanta ladrar.");
  }
}

console.log(animal2);

/* Hay que crear una FUNCIÓN CONSTRUCTORA para
generar nuevas INSTANCIAS, nuevos OBJETOS devenidos
de esta FUNCIÓN CONSTRUCTORA.
Para no tener que copiar y pegar todo los códigos de arriba.
Una función en sí, genera un PROTOTIPO VACÍO.*/

// FUNCIÓN CONSTRUCTORA:
/*
function Animal (name, genero) {
   this.name = name;              // Atributo
  this.genero = genero;           // Atributo
  this.sonar = function () {      // Métodos          
    console.log("Sonidos animalescos de " + this.name);
  }
} */

// OBJETOS BASADOS EN EL PROTOTIPO OBJECT
// Su CONSTRUCTOR es la "función Animal" que cree.
// Pero el prototipo base es el OBJETO OBJECT de JavaScript.
/*
const terry = new Animal("Terry", "Macho");
  perlita = new Animal("Perlita", "Hembra");

console.log(terry);
console.log(perlita);

terry.sonar();
perlita.sonar(); */


//FUNCIÓN CONSTRUCTORA donde asignamos los 
//MÉTODOS AL PROTOTIPO, NO A LA FUNCIÓN COMO TAL.
function Animal (name, genero) {
  this.name = name;              // Atributo
  this.genero = genero;          // Atributo
}

// Método agregados a la FUNCIÓN CONSTRUCTORA:

Animal.prototype.sonar = function () {     // Métodos          
 console.log(`Sonidos animalescos de ${this.name}`);
  }

// HERENCIA PROTOTÍPICA:

function Perro(name, genero, tamanio) {
  this.super = Animal;       //HERENCIA PROTOTÍPICA
  this.super(name, genero);
  this.tamanio = tamanio;
}

//Al prototipo de PERRO le asigno que sea
//una instancia de Animal: PERRO hereda de ANIMAL:
Perro.prototype = new Animal(); 

/*Genero un CONSTRUCTOR a la función constructora.
Así hereda las propiedades del proto Padre ANIMAL,
Puede usar los métodos "sonar" de Animal por ej.
Y puede SOBRE ESCRIBIR el método "sonar"
*/ 
Perro.prototype.constructor = Perro;

// SOBREESCRITURA del método prototipo padre en el hijo:

Perro.prototype.sonar = function() {
  console.log("Soy un can y ladro");
}

Perro.prototype.ladrar = function() {
  console.log("Guauuuuu guauuuuu");
}

  const terry = new Perro("Terry", "Macho", "Grande");
      perlita = new Perro("Perlita", "Hembra", "Pequeña");

console.log(terry);
console.log(perlita);

terry.sonar();
terry.ladrar();
perlita.sonar();
perlita.ladrar();


////////////////////////////////////////////////////

/*CLASES: Son una mejora sintáctica sobre la herencia 
basada en prototipos de JavaScript. La sintaxis de las
clases no introduce un nuevo modelo de herencia
orientada a objetos en JavaScript. sólo proveen una
sintaxis mucho más clara y simple para crear objetos
y lidiar con la herencia.

Las clases son "funciones especiales". La sintaxis
de una clase tiene dos componentes: 
- expresiones de clases. 
Que pueden ser NOMBRADAS o ANÓNIMAS.

// Ejemplo de Expresiones de Clases "Anonima"
let Rectangulo = class {
  constructor(alto, ancho) {
    this.alto = alto;
    this.ancho = ancho;
  }
};

console.log(Rectangulo.name);
// output: "Rectangulo"

// Ejemplo de Expresiones de Clases "Nombrada"
let Rectangulo = class Rectangulo2 {
  constructor(alto, ancho) {
    this.alto = alto;
    this.ancho = ancho;
  }
};
console.log(Rectangulo.name);
// output: "Rectangulo2"


- declaraciones de clases. Como por ejempplo:
class Rectangulo {
  constructor(alto, ancho) {
    this.alto = alto;
    this.ancho = ancho;
  }
}

////////////////////////////////////////////////
HERENCIA PROTOTÍPICA:
Herencia es la capacidad de un CONSTRUCTOR de
heredar "propiedades" y "métodos" de un PADRE
a un HIJO. La HERENCIA se da a manera de 
CADENA PROTOTÍPICA.
*/


/* CLASES: Se les llama azucar sintáctica.
Como JavaScript está orientado a OBJETOS, 
Basado en PROTOTIPOS y no en Clases.
Aunque nosotros escribamos nuestras CLASES.
Javasript lo "compilará" a PROTOTIPOS.
Las CLASES NO RECIBEN PARÁMETROS.El MÉTODO
"constructor" recibe los parámetros / atributos 

Las CLASES simplifican la escritura, pero tras banbalinas
JavaScript interpreta las Clases como un Prototipo.
Porque JS es un lenguaje orientado a OBJETOS
basado en PROTOTYPE. */

class Humanos {
  //El "constructor" de una Clase es un "método especial"
  //que recibe las propiedades de una Clase. Se ejecuta
  //en el momento de crear objetos de este tipo.
  constructor(name, genero) { 
  this.name = name;           // Atributo
  this.genero = genero;       // Atributo
  }
  
  saludo(){  // Métodos. Sí pueden recibir parámetros si los necesitan.  
    console.log(`Hola, me llamo ${this.name}`);
  }

  enfermedad () {  // Métodos          
    console.log("Soy " + this.genero + " y no me siento saludable.");
  }
} 

class Pacientes extends Humanos {
  constructor(name, genero, edad) { 
//Un constructor puede usar la palabra reservada
//super para llamar al constructor de una superclase.
//El método especial "constructor" recibe las propiedades de clase.
//El método super() manda a llamar el constructor de
//la clase padre. 
    super(name, genero)
    this.edad = edad;
    this.nacionalidad = null;
  }

// Sobre-escritura
  saludo(){  // Métodos. Sí pueden recibir parámetros si los necesitan.  
    console.log(`Hola, soy ${this.name} tengo ${this.edad}.`);
  }
    
  dolor() {
    console.log("Estoy con mucho dolor.")
  }

// const messi = new Humanos ("Messi", "Hombre");
// const antonella = new Humanos ("Antonella", "Mujer");

/* Los MÉTODOS ESTÁTICOS: Los métodos estáticos son
llamados sin instanciar su CLASE y no pueden ser
llamados mediante una instancia de clase.
La palabra clave "STATIC" define un método estático 
para una clase. A menudo usados para crear funciones
de utilidad para una aplicación.
Abajo está el método "STATIC" */

  static deDondeEres(){
    console.log("Soy de Argentina, el país CAMPEÓN del MUNDO");
  }
  
  get getNacionalidad(){  // Método obtenedor.
    return this.nacionalidad;
  }
  
  set setNacionalidad(nacionalidad){ // Método de asignación.
    this.nacionalidad = nacionalidad;
  }
}

 ////////////////////////////////////////////////////
/*Métodos SETTER Y GETTERS: 
Hay dos tipos de propiedades de objetos: 
- El 1º tipo son las propiedades de datos.
- El 2º tipo de propiedades de ACCESO. Funciones que
se ejecutan para obtener “get” y asignar “set” un valor.
Son Métodos "getter" y "setter" pero JAVASCRIPT LO
CONVIERTE EN UN "ATRIBUTO".

///////////////////////////////
Las propiedades de "acceso" se construyen con métodos
de obtención “getter” y asignación “setter”. 
En un objeto literal se denotan con get y set:
para establecer y obtener el  valor de un ATRIBUTO 
que existe en nuestra clase, pero que no había sido
definido anteriormente.
   */


Pacientes.deDondeEres();

const messi = new Pacientes ("Messi", "Hombre", 35);
const antonella = new Pacientes ("Antonella", "Mujer", 33);

console.log(messi);
messi.saludo();
messi.enfermedad();
messi.dolor();
console.log(messi.getNacionalidad);
messi.setNacionalidad = "Argentina";
console.log(messi.getNacionalidad);

console.log(antonella);
antonella.saludo();
antonella.enfermedad();
antonella.dolor();
antonella.setNacionalidad = "Argentina";
console.log(antonella.getNacionalidad);

/* MÉTODOS ESTÁTICOS, GETTERS Y SETTERS:
Son características que impactan en el uso de
atributos y métodos de Javascript.
Los MÉTODOS ESTÁTICOS: Es aquel que se puede
ejecutar sin la necesidad de instancias la CLASE. */


/* OBJETOS CONSOLE:
Son útiles conocerlos cuando hacemos TRABAJOS REALES.
Console es un Objeto que JavaScript reconoce.
Console tiene PROPIEDADES y MÉTODOS. */

// MÉTODOS UTILES DE CONSOLE:

console.log(console);
console.error("Esto es un error");
console.warn("Esto es un aviso");
console.info("Mensaje de Información");
console.log("Es un registro de lo que paso en la aplicación");


let nombre5 = "Marina",
 apellido5 = "Aguirre",
 edad5 = 46;

console.log(nombre5);
console.log(apellido5);
console.log(nombre5, apellido5, edad5);
console.log(`Hola, mi nombre es ${nombre5} ${apellido5} y tengo ${edad5} años.`);

//MÉTODOS UTILES EN CONSOLE
//Podemos usar "COMODINES" en la cadena de texto.
//El comodín %s (recibe una cadena de texto)
//El comodín %d (recibe dígitos)
//Luego indico qué reemplaza a cada comodín.
console.log(`Hola, mi nombre es %s %s y tengo %d años.`, nombre5, apellido5, edad5);

//MÉTODO CLEAR: Limpia la consola.
// console.clear()

//MÉTODO window: Muestra las propiedades del OBJETO GLOBAL Window.
console.log(window); 

//DOCUMENT: Representación del documento HTML a través de JavaScript.
// Y podemos acceder a las etiquetas HTML
console.log(document);

//CONSOLE.DIR con Window: Muestra a manera de Objeto JavaScript 
//las propiedades, métodos y constructores del Oonjeto Window.
console.dir(window);

//CONSOLE.DIR con Document:
//Muestra las propiedades, objetos, métodos y atributos 
//del DOCUMENTO. Sirve para representar un elemento como
//UN OBJETO de JavaScript para mostrar sus métodos y atributos.
console.dir(document);

//Podemos "AGRUPAR ELEMENTOS NORMALES" en la consola:

console.group("Así podemos AGRUPAR ELEMENTOS en la CONSOLA");
console.log("Grupo 1 con Curso de JavaScript");
console.log("Grupo 2 con Curso de Node.Js");
console.log("Grupo 3 con Curso de Flexbox");
console.log("Usando Group Y GroupEnd");
console.groupEnd();

//Podemos "AGRUPAR con COLLAPSED" en la consola:

console.groupCollapsed("AGRUPAR ELEMENTOS CON collapsed en la CONSOLA");
console.log("Grupo COLLAPSED 1 con Curso de JavaScript");
console.log("Grupo COLLAPSED2 con Curso de Node.Js");
console.log("Grupo COLLAPSED 3 con Curso de Flexbox");
console.log("Usando GroupCOLLAPSED Y GroupEnd");
console.groupEnd ();

//Podemos hacer TABLAS en la consola:
//podemos representar los datos en forma de tablitas.
// Representa las entradas del Objeto en Tabla:
console.log(console);

// Muestra Tabla desordenada:
console.table(Object.entries(console)); 

// Muestra Tabla en orden alfabético:
console.table(Object.entries(console).sort());

//Representar los Objetos o Arreglos en FORMA DE TABLA:

const numeros5 = [1,2,3,4,5],
   vocales= ["a","e", "i", "o", "u"];

//La tabla indica "índice/posición" y "valor".
console.table(numeros5); 
console.table(vocales);

//La Tabla en OBJETOS sería así:

const Can = {
  mameCan: "Dixi",
  razaCan: "Cocker",
  colorCan: "Cafe con leche",
}

console.table(Can);

//PARA MEDIR EL TIEMPO QUE TARDA UN BLOQUE DE CÓDIGO
//EN EJECUTARSE SE EMPLEA: CONSOLE.TIME:

console.time("Cuanto tarda mi código?");
const array = Array(1000000);

for (let i = 0; i < array.length; i++) {
  array[i] = i;
}

console.timeEnd("Cuanto tarda mi código?");

//console.log(array);


//Para saber cuántas veces se ejecutó un código,
//O cuantas conexiones hizo para llegar a una solicitud
//se coloca: CONCOLE.count(i)

for (let i=0; i <= 20; i++) {
  console.count("Código de bucle for");
  console.log(i);
}
//Arriba podés revisar el código en las partes de ejecución.

//UNA MINILIBRERÍA PARA HACER PRUEBAS ES EL MÉTODO
//CONSOLE.ASSERT

let A = 3,
B = 2,
pruebaAB = "Se espera que X sea menor que Y";

console.assert(A < B, (A,B,pruebaAB));

//CONSTRUCTOR CONSOLE.DATE: Para saber la fecha.
//JavaScript detecta la hora local.
console.log(Date());

//Podemos guardar la variable: fecha
let fecha = new Date();
console.log(fecha);

//Método para saber el DÍA del MES:
console.log(fecha.getDate());

//Método para saber el DÍA de la SEMANA:
//Domingo: 0, Lunes: 1, Martes:2, etc.
console.log(fecha.getDay());

//Método para saber el MES: Enero: 0, Febrero:1, etc.
console.log(fecha.getMonth());

//Método para saber el AÑO
console.log(fecha.getFullYear());

//Método para saber la hora, min y seg.
console.log(fecha.getHours());
console.log(fecha.getMinutes());
console.log(fecha.getSeconds());

//Método fecha en string's:
console.log(fecha.toString());

//Método fecha de en string's:
console.log(fecha.toDateString());

// Más Métodos con fechas:

console.log(fecha.toLocaleString());
console.log(fecha.toLocaleDateString());
console.log(fecha.toLocaleTimeString());
console.log(fecha.getTimezoneOffset());
console.log(fecha.getUTCDate());
console.log(fecha.getUTCHours());
console.log(Date.now()); //Time Stand

//LIBRERÍA POTENTE PARA MANEJAR TIEMPOS EN JS:
//ES MOMENT.JS ==> momentjs.com
//Si tenemos que expresar fechas en una aplicación:
//y para no hacerlo manualmente, usemos esta LIBRERÍA.

//Por ejemplo para saber cuando fue tu cumpleaños:

let cumpleMarina = new Date(1976,4,12);
console.log(cumpleMarina);

///////////////////////////////

/* OBJETO MATH de JavaScript: 
Objeto estático. Debemos invocar al prototipo cada
vez que queremnos invocarlo. Incorpora varias 


/// CONSTANTES MATEMÁTICAS:
Que podemos necesitar en algunas operaciones matemáticas. 

Número de Euler	2.718281828459045
Math.log(2)	0.6931471805599453
Math.log(10)	2.302585092994046
Math.log2(Math.E)	1.4426950408889634
Math.log10(Math.E)	0.4342944819032518
Número PI o Π	3.141592653589793
Math.sqrt(1/2).	0.7071067811865476
sqrt(2). 1.4142135623730951

/// Y MÉTODOS MATEMÁTICOS: 
Que devuelven el...

Math.abs(x)	Valor absoluto de x.	|x|
Math.sign(x) 	Signo del número: 1 positivo, -1 negativo
Math.exp(x)	Número e elevado a x.	exponenciación
Math.expm1(x) Equivalente a - 1.	ex-1
Math.max(a, b, c...)	El número más grande de los indicados por parámetro.	
Math.min(a, b, c...)	Eúmero más pequeño de los indicados por parámetro.	
Math.pow(base, exp)	Potenciación.  Elevado a exp.	baseexp
Math.sqrt(x)	La raíz cuadrada de x.	√x
Math.cbrt(x) 	La raíz cúbica de x.	√3x
Math.imul(a, b) Equivalente a a * b, pero a nivel de bits.	
Math.clz32(x) Devuelve el número de ceros a la izquierda de x en binario (32 bits).


/// MÉTODOS DE LOGARITMOS: 

Desde logaritmos neperianos hasta logaritmos binarios
a través de las siguientes funciones:

- Math.log(x)	Devuelve el logaritmo natural en base e de x.	loge x o ln x
El "logaritmo natural" se conoce como "logaritmo neperiano" aunque esencialmente son conceptos distintos.
Ejemplo: Math.log(2);    // 0.6931471805599453

- Math.log10(x) Devuelve el logaritmo decimal (en base 10) de x.	log10 x ó log x
Conocido com o "Logaritmo común" o "logaritmo vulgar" al logaritmo cuya base es 10.
Ejemplo: Math.log10(2);  // 0.3010299956639812

- Math.log2(x) Devuelve el logaritmo binario (en base 2) de x.	log2 x
O "logaritmo en base 2", es la función matemática que determina a que valor y hay que elevarse a 2 para obtener x.
Math.log2(2);   // 1

- Math.log1p(x)	Devuelve el logaritmo natural de (1+x).	loge (1+x) o ln (1+x)
Math.log1p(2);  // 1.0986122886681096


///MÉTODOS DE REDONDEO: 

Math.round(x)	Redondeo (el entero más cercano)
Math.ceil(x)	Redondeo superior (el entero más alto)
Math.floor(x)	Redondeo inferior (el entero más bajo)
Math.fround(x) Redondeo (flotante con precisión simple)
Math.trunc(x) Trunca el número x (devuelve sólo la parte entera)


/// MÉTODOS TRIGONOMÉTRICOS:

Para hacer cálculos con operaciones como seno, coseno,
tangente y relacionados:


Método	Descripción:
Math.sin(x)	Seno de x
Math.asin(x) Arcoseno de x
Math.sinh(x) Seno hiperbólico de x
Math.asinh(x)	Arcoseno hiperbólico de x
Math.cos(x)	Coseno de x
Math.acos(x) Arcocoseno de x
Math.cosh(x) Coseno hiperbólico de x
Math.acosh(x)	Arcocoseno hiperbólico de x
Math.tan(x)	Tangente de x
Math.atan(x) Arcotangente de x
Math.tanh(x) Tangente hiperbólica de x
Math.atanh(x)	Arcotangente hiperbólica de x
Math.atan2(x, y) Arcotangente del conciente de x/y
Math.hypot(a, b..) Devuelve la raíz cuadrada de a2 + b2 + ...

///////////////////////////////


¿Qué es BigInt? 
Es un tipo de dato de Javascript que nace con la idea
de permitir representar valores muy grandes, de una
forma relativamente sencilla y compatible con lo que
ya existe.

Constructor	   |      Descripción
- BigInt(number): Devolvemos un número BigInt a partir
              de un number pasado por parámetro.

- number+n:	Simplemente, añadir una "n" al final del
            número. Notación preferida.

*/

/// MÉTODOS MÁS USADOS CON MATH.

console.log(Math);
console.log(Math.PI);
console.log(Math.abs(7.8)); //Me dá el Valor absoluto.
console.log(Math.abs(-7.8)); //No importa si es + ó -,
// sigue siendo 7.8 el valor absoluto.
console.log(Math.ceil(7.8)); //Redodea hacia arriba.
console.log(Math.floor(7.8)); //Rodondea hacia abajo.
console.log(Math.round(7.8)); //Redondea al entero más cercano inmediato.
console.log(Math.round(7.49));
console.log(Math.sqrt(81)); // Raíz cuadrada.
console.log(Math.pow(2,5)); //Base x exponente "a la quinta potencia."
console.log(Math.sign(-7.8)); // Indica si el número es positivo, negatico o 0.
console.log(Math.sign(0));
console.log(Math.random()); // Indica un número aleatoria entre 0 y 1.
console.log(Math.random()); 
console.log(Math.random()*1000)
 // Aleatorio entre 0 y mil.con decimales.
console.log(Math.round (Math.random()*1000));
// Número ENTERO Aleatorio entre 0 y mil 

///////////////////////////////


/* OPERADORES DE CORTOCIRCUITO: Or || y AND &&

Or: Cuando el valor izquierdo en la expresión
siempre valide "true", es el valor que se cargará
por defecto.
&&:  Cuando el valor izquierdo en la expresión
siempre valide "false", es el valor que se cargará
por defecto. */

// EJEMPLO COMO SE HACÍA ANTES:
function salutaciones(nombre4 = "Desconocido"){
  console.log(`Hello ${nombre4}`)
}
console.log();

salutaciones("Guadalupe");
salutaciones();


// OPERADOR LÓGICO OR ||:
function salutacion(nombre6){
  nombre6 = nombre6 || "Desconocida"
  console.log(`Hi ${nombre6}`)
}
console.log();

salutacion("Agustina");
salutacion();


///////////////////////////////


/*MÉTODOS DE WINDOW, DEL OBJETO "PADRE" WINDOW:
ALERT, CONFIRM Y PROMPT (FUNCIONES DE WINDOW):
pERMITEN INTERACCIONES BÁSICAS CON EL USUARIO.

console.log(window);

window.alert("Hola, esto es una ALERTA.");
window.confirm("Hola, esto es una CONFIRMACIÓN.");
window.prompt("Esto es un PROMPT y permite al usuario ingresar VALORES.");

NO es necesario poner window adelante de estos MÉTODOS. */
/*
alert("Hola, esto es una ALERTA 2.");
confirm("Hola, esto es una CONFIRMACIÓN 2.");
prompt("Esto es un PROMPT y permite al usuario ingresar VALORES 2.");
*/

/*
let alerta = alert("Hola, esto es una ALERTA3"),
  confirmacion = confirm("Hola, esto es una CONFIRMACIÓN3"),
  aviso = prompt("AVISO que permite al usuario ingresar VALORES3");

  console.log(alerta);
//Envío mensajes al usuario.
  console.log(confirmacion); 
//El Botón ACEPTAR = True. El Botón CANCELAR = False."
  console.log(aviso);
//Escribo y doy "ACEPTAR"  = Refleja lo escrito.
//Escribo y dor "CANCELAR" = Devuelve "NULL" sobre lo escrito.
*/

///////////////////////////////

/*EXPRESIONES REGULARES ó RACIONALES (regex o regexp):

// Definición de Wikipedia:


//Definición en MDN:  
Son patrones que se utilizan para hacer coincidir
combinaciones de caracteres en cadenas.
En JavaScript, las expresiones regulares también
son OBJETOS. Estos patrones se utilizan con los
métodos exec() y test() de RegExp, y con match(),
matchAll(), replace(), replaceAll() (en-US), 
search() y split() métodos de String.
Construyes una expresión regular en una de estas 
dos formas:

1) Usando una expresión regular literal: let re = /ab+c/;
2) O llamando a la función constructora del 
objeto RegExp. Se USA cuando sepas que el patrón 
de la expresión regular cambiará, o no conoces el
patrón y lo obtienes de otra fuente, como la 
entrada del usuario. Sería así:
  let re = new RegExp('ab+c');

DEFINICIÓN DE JON MIRCHA EN You Tube: 

Son una secuencia de caracteres que forma un patrón
de búsqueda, principalmente utilizada para la búsqueda
de patrones de "cadenas de caracteres o string" u 
operaciones de sustitución.

Las "expresiones regulares" no son exclusivas de JavaScript.
Cualquier lenguaje de programación debe terner una 
implementación de estas "expresiones regulares". Ej:
C++, Java, JavaScript, PHP, Python, .Net Framework,
PCRE (Biblioteca de ExReg para C, C++, AWK de Linux/Unix)

Así se construye: 

a) Alternación: Una barra vertical separa las alternativas.

b) Cuantificación: Especifica la frecuencia con la
que este puede ocurrir. Ej: "?", "+" y "*".
? : Indica que el carácter que le precede puede 
aparecer como mucho una vez. Por ejemplo, "ob?scuro"
se corresponde con oscuro y obscuro.
+ : Indica que el carácter que le precede debe 
aparecer al menos una vez. Por ejemplo, "ho+la" 
describe el conjunto infinito hola, hoola, hooola,
hoooola, etcétera.
* : Indica que el carácter que le precede puede
aparecer cero, una, o más veces. Por ejemplo, 
"0*42" se corresponde con 42, 042, 0042, 00042,
etcétera.

c) Agrupación: Los paréntesis pueden usarse para 
definir el ámbito y precedencia de los demás 
operadores. Por ejemplo, "(p|m)adre" es lo mismo
que "padre|madre", y "(des)?amor" se corresponde
con amor y con desamor.

/////////////////////////////

Aplicaciones:

- Estas "expresiones regulares" facilitan la vida 
para validar un e-mail.
- Para validar un DNI o los 16 dígitos de una 
TARJETA DE CRÉDITO para saber si es Visa o Master.
- Su utilidad más obvia es la de describir un 
conjunto de cadenas para una determinada función, 
resultando de utilidad en editores de texto y otras 
aplicaciones informáticas para buscar y manipular 
textos.
- ID de empleados de un empresa / industria. */

//DEFINIR O DECLARAR EXPRESIÓN REGULAR de 2 maneras: 

//Primero: USANDO FUNCIÓN CONSTRUCTORA: /////////

let cadena = "Lorem ipsum dolor sit amet, 130 consectetur adipiscing elit, lorem sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea lorem commodo consequat.";

//1º parámetro: "string" a buscar. Acá es "lorem".
//2º parámetro: "flags" por ej. "g" quer significa "global".
//o sea que busque todas las palabras lorem, y que 
//no se detenga en la primera coicidencia de "lorem" y
// busque todas las palabras "lorem" de la "cadena".
//Por ej. la "flag" "i" ignora entre mayúscula o minúscula y lñas incluye a todas las palabras.

// let expReg = new RegExp("lorem", "ig");
// console.log(expReg.test(cadena));
// console.log(expReg.exec(cadena));

//Segundo: USANDO EXPRESIÓN REGULAR LITERAL:  /////////

//Colocando la expresión regular entre dos barras / /
let expReg2 = /lorem/;

//MÉTODO Test y MÉTODO EXSET

//Método test de expReg.
console.log(expReg2.test(cadena));

//Método exec  de expReg devuelve un arreglo.
console.log(expReg2.exec(cadena));


///////////////////////////////////////////////
//////////////////////////////////////////////

/// ESTE ES EL formato más usado: Literal

/* lista de algunas de estas combinaciones:

\t — Representa un tabulador.
\r — Representa el "retorno de carro" o "regreso al inicio" o sea el lugar en que la línea vuelve a iniciar.
\n — Representa la "nueva línea" el carácter por medio del cual una línea da inicio. Es necesario recordar que en Windows es necesaria una combinación de \r\n para comenzar una nueva línea, mientras que en Unix solamente se usa \n y en Mac_OS clásico se usa solamente \r.
\a — Representa una "campana" o "beep" que se produce al imprimir este carácter.
\e — Representa la tecla "Esc" o "Escape"
\f — Representa un salto de página
\v — Representa un tabulador vertical
\x — Se utiliza para representar caracteres ASCII o ANSI si conoce su código. De esta forma, si se busca el símbolo de derechos de autor y la fuente en la que se busca utiliza el conjunto de caracteres latín-1 es posible encontrarlo utilizando \xA9".
\u — Se utiliza para representar caracteres Unicode si se conoce su código. "\u00A2" representa el símbolo de centavos. No todos los motores de Expresiones Regulares soportan Unicode. El .Net Framework lo hace, pero el EditPad Pro no, por ejemplo.
\d — Representa un dígito del 0 al 9.
\w — Representa cualquier carácter alfanumérico.
\s — Representa un espacio en blanco.
\D — Representa cualquier carácter que no sea un dígito del 0 al 9.
\W — Representa cualquier carácter no alfanumérico.
\S — Representa cualquier carácter que no sea un espacio en blanco.
\A — Representa el inicio de la cadena. No un carácter sino una posición.
\Z — Representa el final de la cadena. No un carácter sino una posición.
\b — Marca la posición de una palabra limitada por espacios en blanco, puntuación o el inicio/final de una cadena.
\B — Marca la posición entre dos caracteres alfanuméricos o dos no-alfanuméricos.
\Q y \E — Se interpreta como literal todo lo que vaya entre estas dos marcas. Ejemplo: "\Q.*\E" se interpreta como el literal ".*"
Los corchetes "[ ]" — Representa "clases de caracteres", 
o sea, agrupar caracteres en grupos o clases. Es un listado válido.
Las llaves "{}" — Indican REPETICIÓN.

*/

let expReg3 = /\d/; // Un número del 0 al 9.

//Devuelve un Verdadero o Falso si se cumple o no el patron dentro de la cadena que buscas.
console.log(expReg3.test(cadena)); 

//Devuelve un ARREGLO con un objeto adentro con las coicidencia. 
//En qué posición del caracter encontró en la fuente de datos.
console.log(expReg3.exec(cadena));


let expReg4 = /[100-200]/; // Un listado de números.
console.log(expReg4.test(cadena)); 
console.log(expReg4.exec(cadena));

let expReg5 = /lorem{1}/; // Un listado de números.
console.log(expReg5.test(cadena));
console.log(expReg5.exec(cadena));

///////////////////////////////////////////////
//////////////////////////////////////////////

///////////////////////////////////////////////
//////////////////////////////////////////////


// FUNCIONES ANÓNIMAS AUTOEJECUTABLES

/* En inglés IIFE (Immediately Invoked Function Expression)

Sirven para encapsular un bloque de código en un
ambito local. Engloban el código que se quiere
ejecutar. O sea... no sólo las definimos, sino que
también las "ejecutamos al crearlas" y NO tienen
nombre.
Permiten pasar parámetros de una manera amigable. */

/*En tiempos de la LIBRERIA jQuery (2006) se usaban
 mucho. O personas que trabajan proyectos con
 VANILLA JS (JavaScript puro sin emplear librerías.
 Es un patrón empleado para l aejecución de código.  */

// FUNCIONES ANÓNIMAS AUTOEJECUTABLES: Cómo funciona?

// Ejemplo: Función nombrada: ALERT
//Ej: "alert" es una function de window cuyo nombre es alert
//y ejecuta lo que está entre () = "Hola function".
//alert("Hola function");

//FUNCIÓN ANÓNIMA AUTO-EJECUTABLE:

//La estructura/cuerpo de una function sería asi:
//Y estaría "encapsulada entre paréntesis ().
//El segundo paréntesis es lo que ejecuta esa función:

//alert("Hola function") //Estructura "Function nombrada"
//function () {} () //Function Declarada
//(function (acá van los parámetros) {}) (); //Estructura de "Function Anónima".
//Sí o sí colocar PUNTO Y COMA; en funciones anónimas.

(function () {
  console.log("Mi primer iiFE");
}) (); 

(function (d, w, c) { //Parámetro/variable d,w,c
 console.log("Mi segunda Immediately Invoked Function Expression iiFE");
 console.log(d);
 console.log(w);
 c.log("Este es un console.log ejecutado con su alias auto-ejecutable");
})(document, window, console);//Asigno parámetros/variables.

//////////////////////////////////
// IMPORTANTEEEEEEEEEEEEEEEEEEEEEE

// 4 fORMAS DE ESCRIBIR FUNCIONES ANÓNIMAS AUTOEJECUTABLES

// CLÁSICA: 
(function () {
  console.log("Versión Clásica Función Anónima Autoejecutable");
}) ();

// CROCKFORD (Libro: JavaScript The Good Parts):
((function () {
  console.log("Versión Crockford Función Anónima Autoejecutable");
}) ());

// UNARIA:
+ function () {
  console.log("Versión Unaria Función Anónima Autoejecutable");
} ();

// FACEBOOK:

! function () {
  console.log("Versión Facebook Función Anónima Autoejecutable");
} ();


// MÓDULOS (IMPORT / EXPORT)
/* Podemos llamar archivos desde HTML y de un archivo
interno de Javascript.
Todo este código está escrito dentro de la ETIQUETA
de HTML script. Pero lo ideal ES QUE EL CÓDIGO ESTÉ
ESCRITO EN ARCHIVOS JAVASCRIPT.
Pero ahora vamos a crear un archivo nuevo: 
TeoriaModulos.html
*/

///////////////////////////////////

    </script> 
 </body>
</html>
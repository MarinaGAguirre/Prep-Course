<!DOCTYPE html>
<html lang="es">

  <head>
    <meta charset="UTF-8">
    <title>Teoría Java Script resumen de Marina Aguirre</title>
  </head>

    <body> 
      <div class="divClassDescripcionPersonal">
        <h1>Ejercicios de YouTube - JavaScript</h1>
        <h3>Resúmen</h3>    
        
     <script>


/* EJERCICIOS de YouTube de JavaScript
PARA HACER y su RESOLUCIÓN:

///////////////////////////////////////////////////

1) Programa una función que cuente el número de caracteres
   de una cadena de texto, pe. miFuncion("Hola Mundo")
   devolverá 10.

/////////////// 1) RESOLUCIÓN con una FUNCIÓN DECLARADA:

/*function cuentoCaracteres(string =""){
 if (!string){
   console.warn("No ingresaste ningún string")
  } else {
    console.info(`La cadena ${string} tiene ${string.length} caracteres`);
  }
}
cuentoCaracteres();
cuentoCaracteres("Hola Mundo"); */


/////////////// 1) RESOLUCIÓN con una FUNCIÓN EXPRESADA: Usando operador ternario !

const cuentoCaracteres = (string="") => //Asignación de la Arrow function
 (!string)                              //Operadores ternarios "!", "?", ":"   
  ? console.warn("No ingresaste ningún string")       //Opciones identadas
  : console.info(`La cadena: ${string}, tiene ${string.length} caracteres.`); // Opciones identadas

cuentoCaracteres();
cuentoCaracteres("Hola gente bella"); 




///////////////////////////////////////////////////

/* 2) Programa una función que te devuelva el texto recortado
   según el número de caracteres indicados, 
   pe. miFuncion("Hola Mundo", 4) devolverá "Hola".

/////////////// 2) RESOLUCIÓN con una FUNCIÓN EXPRESADA y método "slice": */
// Con el Método slice (El método slice(extrae una sección de una cadena
// y devuelve una cadena nueva.)Sintaxis: cadena.slice(inicioTrozo[, finTrozo])


const recortarTexto = (string2 = "", longitud = undefined) => //Asignación de la Arrow function
 (!string2) //Operador ternario  
   ? console.warn("No ingresaste un texto.")
   : (longitud === undefined)
     ? console.warn("No ingresaste la longitud para cortar el Texto.")
   : console.info(string2.slice(0, longitud));

  //Parámetros: Un string y el valor inicial de longitud a cortar (4, o 3 o nada) 
  recortarTexto("Hola Mundo", 4);
  recortarTexto();
  recortarTexto("Hola Mundo", 3);
  recortarTexto("Hola Mundillo");




///////////////////////////////////////////////////

/* 3) Programa una función que dada una String te devuelva un
   Array de textos separados por cierto caracter, 
   pe. miFuncion('hola que tal', ' ')
   devolverá ['hola', 'que', 'tal'].

/////////////// 3) RESOLUCIÓN con una FUNCIÓN EXPRESADA */
//Con Arrow fnuction, en dos OPERADORES TERNARIOS concatenados se resuelve.
//Con método split (divide un string),


const stringToArray = (string3 ="", separador = undefined) => //Las Arrow function tienen un "return" implícito.
(!string3)
   ? console.warn("No ingresaste un String.") //Parte verdadera del operador ternario con arrow function.
   : (separador === undefined)
     ? console.warn("No ingresaste el caracter separador.")
     : console.info(string3.split(separador));

stringToArray("Lorem ipsum dolor sit amet, labore et dolore Ut enim ad minim veniam, quis nostrud exercitation ullamco.", " "); //Separador es un espacio " ".
stringToArray();
stringToArray("Enero,Febrero,Marzo, Abril", ","); //Separador, una coma ","
stringToArray("La Vida es Bella!"); //Sin el segundo parámetro, el separador.




///////////////////////////////////////////////////

/*  4) Programa una función que repita un texto X veces, 
pe. miFuncion('Hola Mundo', 3) devolverá Hola Mundo Hola Mundo Hola Mundo. */

/////////////// 4) RESOLUCIÓN con FUNCIÓN EXPRESADA y Bucle for.

const repetirTexto = (texto = "", veces = undefined) => {
/*  if(!texto) {
    return console.warn("No ingresaste un texto.");
  } 
  if(veces === undefined) {
    return console.warn("No ingresaste el número de veces a repetir el texto.");
  } 
  if(veces === 0) {
    return console.error("El número de veces no puede ser 0.");
  } 
//La función Math.sign retorna el signo de un número. Si es positivo, negativo o 0.
  if(Math.sign(veces) === -1) {
    return console.error("El número de veces no puede ser negativo.");
  } 
  for (let i = 1; i <= veces; i++) {
    console.info(`${texto}, ${i}`);
  }
} */

// También podemos escribir todo SIN LAS LLAVES {}.

if (!texto) return console.warn("No ingresaste un texto.");
if (veces === undefined) return console.warn("No ingresaste el número de veces a repetir el texto.");
if (veces === 0) return console.error("El número de veces no puede ser 0.");

//La función Math.sign retorna el signo de un número. Si es positivo, negativo o 0.
if (Math.sign(veces) === -1) return console.error("El número de veces no puede ser negativo.");

//Acá colocamos un "bucle for" que itere sobre todos los números posibles de ingresar.
for (let i = 1; i <= veces; i++) console.info(`${texto}, ${i}`);
}

repetirTexto("Messi campeón!", 3);
repetirTexto("Messi campeón!", 0);
repetirTexto("Messi campeón!", -5);
repetirTexto("", 7);
repetirTexto("Messi campeón!");





///////////////////////////////////////////////////

/* 5) Programa una función que invierta las palabras
de una cadena de texto, pe. miFuncion("Hola Mundo")
devolverá "odnuM aloH". */

/////////////// 5)RESOLUCIÓN con FUNCIÓN EXPRESADA.
//Con métodos split (divide un string), reverse y join (unir).

const invertirCadena = (cadena3 = "") =>
  (!cadena3)
   ? console.warn("No ingresaste ninguna cadena de texto.")
   : console.info(cadena3.split("").reverse().join(""));
//   : console.info(cadena3.split("").reverse().join()); 
//Si coloco join() sin los comillas adentro (""),
// aparece esto: .,i,s,s,e,M, ,a,l,o,H/


invertirCadena();
invertirCadena("Hola Messi");    // isseM aloH
invertirCadena("Luz azul");      // luza zuL
invertirCadena("Yohagoyogahoy"); // yohagoyogahoY




///////////////////////////////////////////////////
/*
6) Programa una función para contar el número de veces que
se repite una palabra en un texto largo, pe. 
miFuncion("hola mundo adios mundo", "mundo") devolverá 2.

/////////////// 6)RESOLUCIÓN con FUNCIÓN EXPRESADA. */
//Empleando el Método: String.prototype.indexOf()
//Para buscar un objeto String dentro de una cadena.
//Sintaxis: cadena.indexOf(valorBusqueda[, indiceDesde]) */


const palabraEnCadena = (cadena4 = "", palabra = ("")) => {
if (!cadena4) return console.warn("No ingresaste la cadena de texto largo.")
if (!palabra) return console.warn("No ingresaste una palabra para contabilizar.")  
// Empleo de Bucle while: 

  let i = 0,
  contador = 0;
  cadena4 = cadena4.toLowerCase();

  while (i !== -1) {
    i = cadena4.indexOf(palabra, i)
    if(i !== -1){
      i++;
      contador ++
    }
  }
 return console.info(`La palabra "${palabra}" "se repite ${contador} veces.`);
}

palabraEnCadena(); // No ingresaste la cadena de texto largo
palabraEnCadena("","mundo"); // No ingresaste la cadena de texto largo
palabraEnCadena("hola mundo adios mundo",); //No ingresaste una palabra para contabilizar.
palabraEnCadena("Hola Mundo adios mundo Mundo cruel","mundo"); //  La palabra "mundo" "se repite 3 veces
palabraEnCadena("Hola Mundo adios mundo","mundo"); //La palabra "mundo" "se repite 2 veces.






///////////////////////////////////////////////////

/* 7) Programa una función que valide si una palabra
o frase dada, es un palíndromo (que se lee igual en
un sentido que en otro).
pe. mifuncion("Salas") devolverá true.

/////////////// 7) RESOLUCIÓN con FUNCIÓN EXPRESADA.*/

const palíndromo = (palabra2 = "") => {
  if (!palabra2) return console.warn("No ingresaste una palabra o frase palíndromo.")
//JavaScript es sencible a mayúsculas y minúsculas, 
//por eso llevaremos todo a LowerCase (minúsculas).

// Las "palabras o frases" las pasamos a minúscula:
  palabra2 = palabra2.toLowerCase();
// Las "palabras" las seperamos, revertimos y unimos.
  let alReves = palabra2.split("").reverse().join("");
  return (palabra2 === alReves)
   ? console.info(`Si, es palíndromo. Palabra provista ${palabra2}. Palabra al revés ${alReves}`)
   : console.info(`No, no es palíndromo. Palabra provista ${palabra2}. Palabra al revés ${alReves}`);
  }

palíndromo("Salas");
palíndromo("Menem");
palíndromo("Otto");
palíndromo("Messi");
palíndromo();





///////////////////////////////////////////////////

/* 8) Programa una función que elimine cierto patrón
de caracteres de un texto dado: xyz
pe. miFuncion("xyz1, xyz2, xyz3, xyz4 y xyz5", "xyz")
devolverá  "1, 2, 3, 4 y 5. 

/////////////// 8) RESOLUCIÓN con FUNCIÓN ANÓNIMA con return implícito.
Concatenando 2 Operadores ternarios. */
//Expresiones Regulares con arrow function de 2 valores.

const eliminarCaracteres = (texto2 = "", patron = "") =>
 (!texto2)
  ? console.warn("No ingresaste un texto.")
  : (!patron)
    ? console.warn("No ingresaste un patrón.")
//Método de String.replace (Primervalor a buscar: string 
//| RegExp, replaceValue: string): string (+3 overloads)

//1º paámetro una Expresión Reg (RegExp) con el patrón
// a buscar y las banderas "i":evita distinquir mayúscula o minúscula
// y bandera (flaga) "g": ejecuta todas las coicidencias, no sólo la primera.
// y el replace está vacío, no queremos reemplazarlo con nada o la "l".

: console.info(texto2.replace(new RegExp(patron, "ig"),"")) 
//: console.info(texto2.replace(new RegExp(patron, "ig"),"l")) 

eliminarCaracteres(); // No ingresaste un patrón.
eliminarCaracteres("xyz1, xyz2, xyz3, xyz4 y xyz5",); // No ingresaste un patrón
eliminarCaracteres("xyz1, xyz2, xyz3, xyz4 y xyz5", "xy"); // z1, z2, z3, z4 y z5
eliminarCaracteres("xyz1, xyz2, xyz3, xyz4 y xyz5", "xyz"); // 1, 2, 3, 4 y 5
//eliminarCaracteres("Como en puertoRico dicen: Me divertí mucho en el río aunque hacía mucho calor", "r", "l");
eliminarCaracteres("Como en puertoRico dicen: Me divertí mucho en el río aunque hacía mucho calor", "[a-z]"); //Elimina letras de la a "a" la "z".





///////////////////////////////////////////////////

/* 9) Programa una función que obtenga un numero aleatorio
entre 501 y 600.

/////////////// 9) RESOLUCIÓN con Arrow Function con los Métodos

*  Math.round()retorna un número redondeado al entero más cercano.
*  Math.random() que devuelve un número aleatorio entre 0 y 1.*/

const numeroAleatorio = (min, max) => console.info((Math.round(Math.random() * 100) + 500));
numeroAleatorio();





///////////////////////////////////////////////////

/*10) Programa una función que reciba un número y evalúe si es
capicúa o no (que se lee igual en un sentido que en otro),
pe. miFuncion(2002) devolverá true.

/////////////// 10) RESOLUCIÓN con condicional If. 
Método typeof: Devuelve la naturaleza del tipo de datro (número, string, booleano, objeto, etc)
Método.split(), método.reverse(), método.join()   */

const capicua = (numero = 0) => {
  if(!numero) return console.warn("No ingresaste un número.");
  
  if(typeof numero !== "number") return(`El valor "${numero}" ingresado, NO es un número.`);
  
  numero = numero.toString();
  let alReves = numero.split("").reverse().join("");
  
  return (numero === alReves)
   ? console.info(`Sí es capicúa. Número provisto ${numero}. Número capicúa ${alReves}`)
   : console.info(`No es capicúa. Número provisto ${numero}. Número capicúa ${alReves}`)
}

capicua();
capicua("07");
capicua(767);
capicua(18.99);
capicua(17.71);
capicua(2001);




///////////////////////////////////////////////////

/*11) Programa una función que calcule el factorial de un número n positivo.

(Los factoriales regularmente son representados  con la abreviatura n!.
Cuando tú factorizas un número, tú estás multiplicando ese número
por cada  número consecutivo menos uno. Por ejemplo: 

Si tu número es 5 sería asi: 5! = 5 * 4 * 3 * 2 * 1 = 120

pe. miFuncion(5) devolverá 120.
* El FACTORIAL no puede ser NEGATIVO ni CERO.

/////////////// 10) RESOLUCIÓN con BUCLE FOR y Métodos
* typeOf: te dice qué tipo de dato es (número, string, booleano, objeto, etc).
* Math.sign() retorna el signo de un número (positivo, negativo o cero). Sintaxis: Math.sign(x)

*/

const factorial = (numero1 = undefined) =>{
// Si numero 1 es igual a cero, negativo o no se define, 
// retornamos un mensaje de error.
  if(numero1 === undefined) return console.warn("No ingresaste un número.")
  if(typeof numero1 !== "number") return console.error(`El valor "${numero1}" ingresado, NO es un número.`);
  if(numero1 === 0) return console.error("El número no puede ser 0.");
  if(Math.sign(numero1) === -1) return console.error("El número no puede ser negativo.");
  

  let factorial = 1;
  
// Comenzamos el Bucle FOR con "i" = numero1 y 
// Decremento "i" luego de cada iteración del Bucle FOR.
    for (let i = numero1; i >= 1; i--){
// Guardamos el valor de numero1 en factorial y a su vez
// el valor de factorial en cada iteración
      factorial = factorial * i 
    //factorial *= i; // Simplificando los operadores aritméticos.
    }
    //return console.info(numero1);
    return console.info(`El factorial de ${numero1} es ${factorial}.`);
}

factorial();
factorial("5");
factorial([1,2,3]);
factorial(0);
factorial(-5);
factorial(7);
factorial(5);




///////////////////////////////////////////////////

/* 12) Programa una función que determine si un número 
es primo (sólo es divisible por sí mismo y por 1).
El 0 y el 1 NO son primos. Ejemplo:
miFuncion(7) devolverá true. 

/////////////// 12) RESOLUCIÓN con FUNCIÓN EXPRESADA con Bucle FOR y
* typeOf: te dice qué tipo de dato es (número, string, booleano, objeto, etc).

*/

const numeroPrimo = (numero2 = undefined) => {

  if (numero2 === undefined) return console.warn("No ingresaste un número.");
  if(typeof numero2 !== "number") return console.error(`El valor "${numero2}" ingresado, NO es un número.`);  
  if (numero2 === 0) return console.warn("El numero 0 no es primo.");
  if (numero2 === 1) return console.warn("El numero 1 no es primo.");
  if(Math.sign(numero2) === -1) return console.error("El número no puede ser negativo.");
  

  let numeroDivisible = false;

  //La "i"(inicializador) debe comenzar en 2 porque 0 y 1 NO son primos.
  for (var i = 2; i < numero2; i++)  {
    if ((numero2 % i) === 0) {
      numeroDivisible = true;
      break;
    }
   }
   return (numeroDivisible)
    ? console.log(`El número ${numero2}, NO es primo.`)
    : console.log(`El número ${numero2}, sí es primo.`);
}

numeroPrimo();
numeroPrimo(0);
numeroPrimo("7");
numeroPrimo(true);
numeroPrimo(-7);
numeroPrimo(7);
numeroPrimo(13);
numeroPrimo(200);





///////////////////////////////////////////////////

/* 13) Programa una función que determine si un número 
es par o impar, pe. miFuncion(29) devolverá Impar.

/////////////// 13) RESOLUCIÓN*/

const numeroParImpar = (numero3 = undefined) => {

if (numero3 === undefined) return console.warn("No ingresaste un número.");
if(typeof numero3 !== "number") return console.error(`El valor "${numero3}" ingresado, NO es un número.`);  

return ((numero3 % 2) === 0)
  ? console.log(`El número ${numero3}, es PAR.`)
  : console.log(`El número ${numero3}, es IMPAR.`);
}

numeroParImpar();
numeroParImpar("23");
numeroParImpar(-398);
numeroParImpar(19);


///////////////////////////////////////////////////

/*  14) Programa una función para convertir grados 
Celsius a Fahrenheit y viceversa. Ejemplo: 
miFuncion(0,"C") devolverá 32°F.

/////////////// 13) RESOLUCIÓN con FUNCIÓN EXPRESADA y
Método typeof, Método length, Espresión Regular y Bucle FOR. */

const celsiusAFahrenheit = (grados = undefined, unidad = undefined) => {

  if (grados === undefined) return console.warn("No ingresaste grados a convertir.");
  if(typeof grados !== "number") return console.error(`El valor "${grados}" ingresado, NO es un número.`);  
  if (unidad === undefined) return console.warn("No ingresaste el tipo de grado a convertir.");
  if (typeof unidad !== "string") console.error(`El valor "${unidad}" ingresado, NO es unacadena de texto.`);
// Evaluamos con una RegExp (Expresión Regular) si son "C" (centigrados) y "F" Fahrenheit.
  if (unidad.length !== 1 || !/(C|F)/.test(unidad)) return console.warn("Valor de unidad no reconocido.")

if(unidad === "C"){
  return console.info(`${grados}ºC = ${Math.round((grados*(9/5)) + 32)}ºF`); 
  } else if (unidad === "F") {
    console.info(`${grados}ºF = ${Math.round((grados -32) * (5/9))}ºC`); 
  } else {
    return console.error("El tipo de grados a convertir no es válido");
  }  
 }

celsiusAFahrenheit();
celsiusAFahrenheit("2");
celsiusAFahrenheit(2);
celsiusAFahrenheit(2,true);
celsiusAFahrenheit(2, "E");
celsiusAFahrenheit(0,"C");
celsiusAFahrenheit(37,"C");
celsiusAFahrenheit(3,"F");
celsiusAFahrenheit(99,"F");





///////////////////////////////////////////////////

/* 15)  Programa una función para convertir números de 
base binaria (Sólo tienen 0 y 1 y es un sistema de base 2)
a decimal (tiene unidades enteras y una fracción decimal)
​y viceversa. Ejemplo: 
miFuncion(100,2) devolverá 4 base 10.

/////////////// 15) RESOLUCIÓN con FUNCIÓN EXPRESADA y
Métodos typeof, y Método parseInt Convierte un string y
devuelve un entero de la base especificada.
Sintaxis de parseInt:  parseInt(string, base) */

const binarioaADEcimal = (numero4 = undefined, base = undefined) => {
  if(numero4 === undefined) return console.warn("No ingresaste un número a convertir");
  if(typeof numero4 !== "number") return console.warn(`El valor ${numero4} ingresado NO es un número.`);
  if(base === undefined) return console.warn("No ingresaste una base a convertir");
  if(typeof base !== "number") return console.warn(`El valor ${base} ingresado NO es un número.`);
  
  if (base === 2){
    return console.info(`${numero4} base ${base} = ${parseInt(numero4, base)} base 10`);
  } else if (base === 10){
    return console.info(`${numero4} base ${base} = ${(numero4.toString(base))} base 2`);
  } else {
  //Si el usuario brinda un valor en la base que no sea 2 o 10
  //decimos el siguiente mensaje de error:
    return console.error(`El tipo de base a convertir no es válido.`);
  }
}

binarioaADEcimal();
binarioaADEcimal("3");
binarioaADEcimal(100);
binarioaADEcimal(100, "4");
binarioaADEcimal(100,2);
binarioaADEcimal(1110010,2);
binarioaADEcimal(4,10);
binarioaADEcimal(114,10);
binarioaADEcimal(114,3);





///////////////////////////////////////////////////
/*
16) Programa una función que devuelva el monto final después
de aplicar un descuento a una cantidad dada, Ejemplo:
miFuncion(1000, 20) devolverá 800.


/////////////// 16) RESOLUCIÓN con FUNCIÓN EXPRESADA */

const aplicarDescuento = (montoInicial = undefined, descuento = 0) =>{
  if (montoInicial === undefined) return console.warn("No ingresaste el monto.");
  if (typeof montoInicial !== "number") return console.error(`El valor "${montoInicial}" NO es un número.`);
  if (montoInicial === 0) return console.error("El monto no puede ser 0.");
  if (Math.sign(montoInicial) === -1) return console.error("El monto no puede ser negativo.");
  if (typeof descuento !== "number") return console.error(`El valor "${descuento}" NO es un número.`);
  if (Math.sign(descuento) === -1) return console.error("El descuento no puede ser negativo.");

  return console.info(`$${montoInicial} - ${descuento}% = $${montoInicial - ((montoInicial * descuento) / 100)}`);
}

aplicarDescuento();
aplicarDescuento(0);
aplicarDescuento("200");
aplicarDescuento(-200);
aplicarDescuento(100, "0");
aplicarDescuento(1000, -20);
aplicarDescuento(1000, 25);
aplicarDescuento(10500,14);





///////////////////////////////////////////////////

/*
17) Programa una función que dada una fecha válida 
determine cuantos años han pasado hasta el día de hoy,
miFuncion(new Date(1984,4,23)) devolverá 35 años (en 2020).*/

/* /////////////// 17) RESOLUCIÓN con FUNCIÓN EXPRESADA con 

* OPERADOR instanceof: Verifica si un objeto en su cadena de 
  prototipos contiene la propiedad prototype de un constructor.
  Sintaxis de instanceof: objeto instanceof constructor

* DATE.prototype.getTime(): El método getTime() devuelve el valor
  numérico correspondiente a la hora para la fecha especificada 
  según la hora universal. 
  Sintaxis de getTime(): dateObj.getTime()
  El valor devuelto de getTime() es un número de milisegundos.

* Método Math.abs(): Da el Nº absoluto sin importar si es positivo o negativo. 

* Método Math.getFullYear(): Devuelve el año de la fecha indicada acorde a la hora local.

*/

const calcularAnios=(fecha = undefined) => {
  if (fecha === undefined) return console.warn("No ingresaste una fecha.");

// Operador Instanceof: verifica si un objeto en su cadena de prototipos
// contiene la propiedad prototype de un constructor. 
// Se usa necesite confirmar el tipo de un objeto en tiempo de ejecución.
// Sintaxis Instanceof: objeto instanceof constructor

  if (!(fecha instanceof Date)) return console.error("El valor ingresado NO es una fecha válida.")

// Método getTime(): Devuelve la fecha en formato Time.
// Esto de abajo está expresado en milisegundos.
  let hoyMenosFecha = new Date().getTime() - fecha.getTime(),

  // Acá calculo los milisegundos, los minutos, una hora, 24 horas, y los días del año.
  aniosEnMS = 1000 * 60 * 60 * 24 * 365
  // decadasEnMS = 1000 * 60 * 60 * 24 * 365 * 10 Si quiero saber décadas.
  aniosHumanos = Math.floor(hoyMenosFecha/aniosEnMS);

//Método Math.abs(): Da el Nº absoluto sin importar si es positivo o negativo. 
//Método Math.getFullYear(): Devuelve el año de la fecha indicada acorde a la hora local.
//Un Operador ternario tiene 1 parte VERDADERA ? y 1 parte FALSA:

  return (Math.sign(aniosHumanos) === -1)
  ? console.info(`Faltan ${Math.abs(aniosHumanos)} años para el ${fecha.getFullYear()}.`)
  : (Math.sign(aniosHumanos) === 1)
    ? console.info(`Han pasado ${aniosHumanos} años, desde ${fecha.getFullYear()}.`)
    : console.info(`El año actual es ${fecha.getFullYear()}.`)
}

calcularAnios();
calcularAnios({});
calcularAnios(false);
calcularAnios(new Date());
calcularAnios(new Date(1976, 5, 12));
calcularAnios(new Date(2030, 5, 10));





/* ///////////////////////////////////////////////////

18) Programa una función que dada una cadena de texto cuente
el número de vocales y consonantes. EJEMPLO:  
miFuncion("Hola Mundo") devuelva Vocales: 4, Consonantes: 5. 

Se resuelve con

* Bucle FOR OF: Recorre un bucle iterable sobre un elemento iterable. 

* Método test() de RegEXp (Expresión Regular): Evalúa lo que hay
dentro de la Expresión Regular. Por ejemplo vocales.

*/


const cuentoLetras = (cadena = "") => {
 if (!cadena) return console.warn("No ingresaste una cadena de texto");
 if (typeof cadena !== "string") return console.error(`El valor ingresado "${cadena}", NO es una cadena de texto`);
 
 let vocales = 0;
 let consonantes = 0;

 cadena = cadena.toLocaleLowerCase();

 for (let letra of cadena) {
  //Evaluamos con una Reg.Exp y el método test.():
  //Agrupamos las letras a evaluar entre corchetes [].
  if(/[aeiouáéíóúü]/.test(letra)){
    vocales ++;
  }

  if(/[bcdfghjklmnñpqrstvxzwy]/.test(letra)){
    consonantes ++;
  }
 }
  return console.info({
    cadena: cadena,
    vocales: vocales,
    consonantes: consonantes,
  })
}

cuentoLetras();
cuentoLetras(3);
cuentoLetras("Hola Mundo");
cuentoLetras("Ñoño");





///////////////////////////////////////////////////
///////////////////////////////////////////////////
///////////////////////////////////////////////////

//DOM :Es el API de JavaScript para interactuar con HTML.
//Dentro del DOM veremos formularios y las RegExp que se
//emplean para validar formularios.

/* 19) Programa una función que valide que un texto sea un 
Nombre válido. EJEMPLO: miFuncion("Jonathan MirCha") 
Devolverá verdadero. */

/* /////////////// 19) RESOLUCIÓN con FUNCIÓN EXPRESADA
y EXPRESIONES REGULARES */

const validarNombre = (nombre7 = "") => {

  if (!nombre7) return console.warn("No ingresaste un nombre");
  if (typeof nombre7 !== "string") return console.error(`El valor "${nombre7}", NO es una cadena de texto`);

  /* En RegExp estos símbolos significan:
^  (No puede haber nada antes de la expresión a validar)
$  (No puede haber nada después de la expresión a validar)
[] (Son agrupadores de lo que tienen dentro)
\s (Son los espacios en blanco)
+  (Para que lo evalúe por cada caracter que posee la cadena de texto)
g  (Es el comodín que realiza una búsqueda global, buscando en
   toda la cadena y devolviendo todas las coincidencias.)
*/

  let regExp = /^[A-Za-zÑñÁáÉéÍíÓóÚúüÜ\s]+$/g.test(nombre7);
   return (regExp)
   ? console.info(`"${nombre7}", es un nombre válido.`) //Si es válido se ejecuta ésto
   : console.warn(`"${nombre7}", NO es un nombre válido.`)// Si es inválido.
}

validarNombre();
validarNombre(3);
validarNombre("indumentaria");
validarNombre("Marina Guadalupe");
validarNombre("marina 46");





///////////////////////////////////////////////////

/* 20) Programa una función que valide que un texto sea un
email válido. EJEMPLO: miFuncion("jonmircha@gmail.com") 
devolverá verdadero. */


/* /////////////// 20) RESOLUCIÓN con FUNCIÓN EXPRESADA
y EXPRESIONES REGULARES */

 /* En RegExp estos símbolos significan:
[a-z]   (Que sean minúsculas)
[0-9]   (Que sean números)
\.      (Que tenga el punto)
[_a-z]  (Guión bajo y minúsculas)
\s      (Son los espacios en blanco)
+       (Para que lo evalúe por cada caracter que posee la cadena de texto)
*@      (Que tenga Arroba)
{2,15}  (Que tenga de 2 a 15 letras)
g       (Es el comodín que realiza una búsqueda global, buscando en
         toda la cadena y devolviendo todas las coincidencias.
*/

const validarCorreo = (email2 = "") => {
  if (!email2) return console.warn("No ingresaste un email válido.");
  if (typeof email2 !== "string") return console.error(`El valor "${email2}" ingresado, NO es una email.`);

  let regExp = /[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})/i.test(email2);

   return (regExp)
   ? console.info(`"${email2}", es un email válido.`) //Si es válido se ejecuta ésto
   : console.warn(`"${email2}", NO es un email válido.`)// Si es inválido.
}

validarCorreo();
validarCorreo(46);
validarCorreo("MarinaAguirre");
validarCorreo("maguirre.neticel@gmail.com");





/////////////////////////////////////////////////// 

/* 21) Programa una función que dado un array numérico
       devuelve otro array con los números elevados al cuadrado,
       mi_funcion([1, 4, 5]) devolverá [1, 16, 25].*/

/* /////////////// 20) RESOLUCIÓN con FUNCIÓN EXPRESADA */

/*/ Operador Instanceof: verifica si un objeto en su cadena de prototipos
contiene la propiedad prototype de un constructor. Se usa 
cuando se necesite confirmar el tipo de un objeto en tiempo de
ejecución.  Sintaxis Instanceof: objeto instanceof constructor.

* Método Array.length: Para ver el largo del array.

* Bucle For of: Ejecuta un bloque de código para cada elemento
de un objeto iterable. Sintaxis: 
for (variable of iterable) {
  statement
}

* Array.map(): Genera un nuevo array a partir del array original,
con las modificaciones que uno desee.
*/


const arrayAlCuadrado = (array1 = undefined) => {
   if (array1 === undefined) return console.warn("No ingresaste un arreglo de números");

//Cuando ingresemos algo distinto a un Array:
   if (!(array1 instanceof Array)) return console.error("El valor ingresado NO es un arreglo.");

//if (!Array.isArray(obj)) return console.error("El valor ingresado NO es un arreglo.");
  if (array1.length === 0) return console.error("El array está vacío.");

//Bucle for of: Si no se introduce un número
  for (let numero5 of array1){
    if (typeof numero5 !== "number") return console.error(`El valor ${numero5}, NO es un número.`)
    ;
  }

// Elevo al cuadrado los "elementos" del nuevo Arreglo: 
  const newArray = array1.map( element => element * element);
// El Salto de línea es: \n
  return console.info(`Array original: ${array1},\nNew Array al cuadrado: ${newArray}.`)
  
}

arrayAlCuadrado();
arrayAlCuadrado(true);
arrayAlCuadrado({});
arrayAlCuadrado([]);
arrayAlCuadrado([1,4,{}]);
arrayAlCuadrado([1,"3",4]);
arrayAlCuadrado([1,4,8]);






/////////////////////////////////////////////////// 

/* 22) Programa una función que dado un array devuelva el 
   número mas alto y el más bajo de dicho array. EJEMPLO:
   miFuncion([1, 4, 5, 99, -60]) devolverá [99, -60]. */

/* /////////////// 20) RESOLUCIÓN con 
Salto de línea es: \n
* Math.max() es una función(Método) que retorna el mayor número del valor dado. 
En este caso del Array.

* SPREAD SYNTAX ó SPREAD OPERADOR: Permite a un objeto iterable
(Array u objeto) ser espandido donde cero o más elementos o
argumentos son esperables.   */

const arrayMinMax = (array3 = undefined) => {
   if (array3 === undefined) return console.warn("No ingresaste un arreglo de números");

//Cuando ingresemos algo distinto a un Array:
   if (!(array3 instanceof Array)) return console.error("El valor ingresado NO es un arreglo.");

//if (!Array.isArray(array3)) return console.error("El valor ingresado NOOOO es un arreglo.");
   if (array3.length === 0) return console.error("El array está vacío.");

//Bucle for of: Si no se introduce un número

for (let numero8 of array3) {
    if (typeof numero8 !== "number") return console.error(`El dato ${numero8}, NO es un número`)
    ;
  }

  return console.info(`Array original: ${array3}\nValor Mayor: ${Math.max(...array3)}.\nValor Menor: ${Math.min(...array3)}`)
  ;
}

arrayMinMax();
arrayMinMax(false);
arrayMinMax(["Hola"]);
arrayMinMax([]);
arrayMinMax([2,3,"4"]);
arrayMinMax([1, 4, 5, 99, -60]);






/////////////////////////////////////////////////// 

/* 23) Programa una función que dado un array de números
   devuelva un objeto con 2 arreglos en el primero almacena
   los números pares y en el segundo los impares. EJEMPLO:
   miFuncion([1,2,3,4,5,6,7,8,9,0]) 
   devolverá {pares: [2,4,6,8,0], impares: [1,3,5,7,9]}. */

/* /////////////// 20) RESOLUCIÓN con Método FILTER

* Array.prototype.filter():
El método filter() crea un nuevo array con todos los elementos
que cumplan la condición implementada por la función dada.  */

const separoParesImpares = (array4 = undefined) => {

  if (array4 === undefined) return console.warn("No es un arreglo de números.");
  if (!(array4 instanceof Array)) return console.error("No es un arreglo el valor ingresado.");
  if (array4.length === 0) return console.error("Este arreglo está vacío.");
  
  for (let numeritos of array4) {
    if (typeof numeritos !== "number") return console.error(`El dato ${numeritos}, NO es un numero`);
  }
  
  return console.info({
    pares: array4.filter(numeritos => numeritos % 2 === 0),
    impares: array4.filter(numeritos => numeritos % 2 === 1),
  })
}

separoParesImpares();
separoParesImpares("Hola");
separoParesImpares([]);
separoParesImpares([2,4,"j"]);
separoParesImpares([1,2,3,4,5,6,7,8,9,0]);







/////////////////////////////////////////////////// 

/* 24) Programa una función que dado un arreglo de números
devuelva un objeto con dos arreglos, el primero tendrá los
numeros ordenados en forma ascendente y el segundo de forma
descendiente. EJEMPLO: 
miFuncion([7, 5,7,8,6]) devolverá { asc: [5,6,7,7,8],
                        desc: [8,7,7,6,5] }. */

/* ////////// 24) RESOLUCIÓN con Métodos:
 .sort() .map() .reverse() .length() instanceof 

* Array.prototype.sort(): DEvuelve un arreglo (array) localmente
y devuelve el arreglo ordenado. Sintaxis: arr.sort([compareFunction])
firstEl: El 1º elemento a comparar. secondEl: El 2º elemento a comparar.

function compare(a, b) {
  if (a es menor que b según criterio de ordenamiento) {
    return -1;
  }
  if (a es mayor que b según criterio de ordenamiento) {
    return 1;
  }
El modo de ordenación por defecto responde a la posición del
valor del string de acuerdo a su valor Unicode.

* El método .map() crea un nuevo array con los resultados de la
llamada a la función indicada aplicados a cada uno de sus
elementos. Sintaxis: arr.sort([compareFunction]).

* El método .reverse() invierte el orden de los elementos de un 
array in place. El primer elemento pasa a ser el último y el 
último pasa a ser el primero. */

const arreglosOrdenados = (array5 = undefined) => {

if (array5 === undefined) return console.warn("Esto NO es un arreglo de números.");

if (!(array5 instanceof Array)) return console.error("No es un arreglo lo que ingresó.");

if (array5.length === 0) return console.error("Está vacío el arreglo ingresado.");

for (let numerito of array5) {
  if (typeof numerito !== "number") return console.error(`El dato ${numerito}, NO es un numero`)
  ;
}

return console.info({
 array5: array5,
 ascendente: array5.map(element => element).sort(),
 descendente: array5.map(element => element).sort().reverse()
  })
}

arreglosOrdenados();
arreglosOrdenados("Hola");
arreglosOrdenados([]);
arreglosOrdenados([3, true]);
arreglosOrdenados([3,4]);
arreglosOrdenados([7,5,7,8,6]);





/////////////////////////////////////////////////// 

/* 25) Programa una función que dado un arreglo de elementos,
elimine los duplicados, EJEMPLO: 
miFuncion(["x", 10, "x", 2, "10", 10, true, true])
devolverá ["x", 10, 2, "10", true]. */

/* ////////// 25) RESOLUCIÓN con Métodos:
.length() instanceof .filter() .indexOf() Objeto SET
 
* Array.prototype.filter():
El método filter() crea un nuevo array con todos los elementos
que cumplan la condición implementada por la función dada.

* Operador Instanceof: verifica si un objeto en su cadena de prototipos
contiene la propiedad prototype de un constructor. Se usa 
cuando se necesite confirmar el tipo de un objeto en tiempo de
ejecución.  Sintaxis Instanceof: objeto instanceof constructor.

* Método Array.length: Para ver el largo del array.

* Método Array.prototype.indexOf() retorna el primer índice en
el que se puede encontrar un elemento dado en el array, ó retorna
-1 si el elemento no esta presente.
Sintaxis: array.indexOf(searchElement[, fromIndex])


* OBJETO SET: Permite almacenar valores únicos de 
cualquier tipo, ya sea valores primitivos o 
referencias a objetos. Son colecciones de valores.

PERMITE GENERAR UN OBJETO SIN DATOS DUPLICADOS.

Puede iterar a través de los elementos de un conjunto
en orden de inserción. Un valor en un Set solo puede
ocurrir una vez; es único en la colección del Set.

* SPREAD SYNTAX ó SPREAD OPERADOR: Permite a un objeto iterable
(Array u objeto) ser espandido donde cero o más elementos o
argumentos son esperables.

 */

const eliminarDuplicados = (array6 = undefined) => {

if (array6 === undefined) return console.warn("Esto NO es un arreglo de números.");

if (!(array6 instanceof Array)) return console.error("No es un arreglo lo que ingresó.");

if (array6.length === 0) return console.error("Está vacío el arreglo ingresado.");

if (array6.length === 1) return console.warn("Debe haber al menos 2 elementos en el arreglo.");

// Self hace referencia al mismo arreglo.

//return console.info({
//  original: array6,
//  sinDuplicados: array6.filter((value, index, self) => self.indexOf(value) === index)
//  });
//}

//Abajo empleamos el Objeto SET, y antes de declarar el 
//new SET agregamos el ... "Spread syntax" o spread operator (...)
return console.info({
  original: array6,
  sinDuplicados: [...new Set(array6)]
  });
}

eliminarDuplicados();
eliminarDuplicados({});
eliminarDuplicados([]);
eliminarDuplicados([8]);
eliminarDuplicados(["x", 10, "x", 2, "10", 10, true, true]);





/////////////////////////////////////////////////// 

/* 26) Programa una función que dado un arreglo de números 
obtenga el promedio. EJEMPLO:
 promedio([9,8,7,6,5,4,3,2,1,0]) devolverá 4.5. */

/* ////////// 26) RESOLUCIÓN con Métodos:
.length() instanceof .typeof
 
* Operador Instanceof: verifica si un objeto en su cadena de prototipos
contiene la propiedad prototype de un constructor. Se usa 
cuando se necesite confirmar el tipo de un objeto en tiempo de
ejecución.  Sintaxis Instanceof: objeto instanceof constructor.

* Método Array.length: Para ver el largo del array.

* .typeOf(): Te dice qué tipo de dato es (número, 
string, booleano, objeto, etc).

* Array.prototype.reduce(): Método reduce() ejecuta
una función reductora sobre cada elemento de un 
array, devolviendo como resultado un único valor. 
Sintaxis:
arr.reduce(callback(acumulador, valorActual[, índice[, array]])[, valorInicial])
Recibe cuatro argumentos:
1 valorAnterior. 2 valorActual. 3 indiceActual. 4 array.
*/

 const promedio = (array7 = undefined) => {

  if (array7 === undefined) return console.warn("NO es un arreglo de números.");

  if (!(array7 instanceof Array)) return console.error("No es un arreglo lo que ingresó.");

  if (array7.length === 0) return console.error("Está vacío el arreglo ingresado.");

  for (let numerito1 of array7) {
    if (typeof numerito1 !== "number") return console.error(`El dato ${numerito1}, NO es un numero`)
    ;
  }
return console.info (
  array7.reduce((acumulador, numeroActual, index, array7) => {
    acumulador += numeroActual;
    if (index === array7.length-1) {
    return `El promedio de ${array7.join(" + ")} es ${acumulador / array7.length}`; // El promedio de 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0 es 4.5
    //return `El promedio de ${array7} es ${acumulador / array7.length}`; // El promedio de 9,8,7,6,5,4,3,2,1,0 es 4.5
    } else {
      return acumulador;
    }
  })
 )
}

promedio();
promedio({});
promedio([]);
promedio([2, false]);
promedio([9,8,7,6,5,4,3,2,1,0]);





/////////////////////////////////////////////////// 

/*  27) Programa una clase llamada Pelicula.

 ////////// 26) RESOLUCIÓN con Métodos:


La clase recibirá un objeto al momento de instanciarse
con los siguentes datos: id de la película en IMDB, 
titulo, director, año de estreno, país o países de origen,
géneros y calificación en IMBD.

- Todos los datos del objeto son obligatorios.
- Valida que el id IMDB tenga 9 caracteres, los primeros 2 sean letras y los 
  7 restantes números.
- Valida que el título no rebase los 100 caracteres.
- Valida que el director no rebase los 50 caracteres.
- Valida que el año de estreno sea un número entero de 4 dígitos.
- Valida que el país o paises sea introducidos en forma de arreglo.
- Valida que los géneros sean introducidos en forma de arreglo.
- Valida que los géneros introducidos esten dentro de los géneros 
  aceptados*.
- Crea un método estático que devuelva los géneros aceptados*.
- Valida que la calificación sea un número entre 0 y 10 pudiendo ser 
  decimal de una posición.
- Crea un método que devuelva toda la ficha técnica de la película.
- Apartir de un arreglo con la información de 3 películas genera 3 
  instancias de la clase de forma automatizada e imprime la ficha técnica 
  de cada película.
    
Géneros Aceptados: Action, Adult, Adventure, Animation,
Biography, Comedy, Crime, Documentary ,Drama, Family, 
Fantasy, Film Noir, Game-Show, History, Horror, Musical, 
Music, Mystery, News, Reality-TV, Romance, Sci-Fi, Short,
Sport, Talk-Show, Thriller, War, Western.*/

class Pelicula {
//Pasamos de forma destructurada los valores con {}
  constructor ({id, titulo, director, estreno, pais, generos, calificacion}) {
   this.id = id;
   this.titulo = titulo;
   this.director = director;
   this.estreno =  estreno;
   this.pais = pais;
   this.generos = generos;
   this.calificacion = calificacion;

   this.validarIMDB(id);
   this.validarTitulo(titulo);
   this.validarDirector(director);
   this.validarEstreno(estreno);
   this.validarPais(pais);
   this.validarGeneros(generos);
   this.validarCalificacion(calificacion);
   }

// Creo un ATRIBUTO ESTÁTICO de tipo "getter" llamado 
//"listaGeneros" que retornará un Arreglo con los géneros permitidos.
   static get listaGeneros() {
    return [ "Action", "Adult", "Adventure", "Animation", "Biography", "Comedy", "Crime", "Documentary", "Drama", "Family", "Fantasy", "Film Noir", "Game-Show", "History", "Horror", "Musical", "Music", "Mystery", "News", "Reality-TV", "Romance", "Sci-Fi", "Short", "Sport", "Talk-Show", "Thriller", "War", "Western."];
   }

//Método estático:

   static generosAceptados(){
    return console.info(`Los géneros aceptados son: ${Pelicula.listaGeneros.join(", ")} `);
   }

   validarCadena(propiedad, valor) {
    if(!valor) return console.warn(`${propiedad} "${valor}" está vacío.`);
    if(typeof valor !== "string") return console.error(`${propiedad} ${valor} no es una cadena de texto`);
     return true;
   }

   validarLargoCadena(propiedad, valor, longitud) {
    if(valor.length > longitud) return console.error(`${propiedad} "${valor}" excede la cantidad de caracteres válidos (${longitud}).`);
    return true;
   }

   validarNumero(propiedad, valor) {
    if(!valor) return console.warn(`${propiedad} "${valor}" está vacío.`);
    if(typeof valor !== "number") return console.error(`${propiedad} ${valor} no es un número`);
     return true;
   }

   validarArray(propiedad, valor) { 
    if (!valor) return console.warn(`${propiedad} "${valor}" está vacío.`);
    if (!(valor instanceof Array)) return console.error(`${propiedad} "${valor}" ingresado NO es un Arreglo.`);
    if (valor.length === 0) return console.error(`${propiedad} "${valor}" no tiene datos.`);
    for (let cadena5 of valor) {
      if (typeof cadena5 !== "string") return console.error(`El valor ${cadena5}, NO es una cadena de texto.`);
      }
    return true;
    }

  //La condición de "IMDB id" tiene una RegExp (Espresión Regular) que debe validarse a true.  
  //Uso el ^: No debe haber nada antes. $: No debe haber nada después.
  //(): Para agrupar que debe haber.
  
   validarIMDB(id){
    if (this.validarCadena("IMDB id", id)) 
      if(!(/^([a-z]){2}([0-9]){7}$/.test(id))) 
        return console.error(`IMDB id ${id} no es válido. Debe tenger 9 caracteres, los primeros 2 letras minúsculas y los 7 restantes números`);
   }

   validarTitulo(titulo){
    if (this.validarCadena("Titulo", titulo)) 
      this.validarLargoCadena("Titulo", titulo, 50);
   }

   validarDirector(director){
    if (this.validarCadena("Director", director)) 
      this.validarLargoCadena("Director", director, 30);
   }

   validarEstreno(estreno){
    if (this.validarNumero("Año de Estreno", estreno)) 
      if(!(/^([0-9]){4}$/.test(estreno))) 
        return console.error(`Año de estreno ${estreno} no es válido. Debe tenger 4 dígitos el número.`);
   }

   validarPais(pais) {
    this.validarArray("País", pais)
   }

// Con el Método .includes() buscamos si el género introducido
// está incluido dentro de la "listaGeneros" para validar con
// false o true.
   validarGeneros(generos) {
    if (this.validarArray("Generos", generos)) {
      for (const genero of generos) {
        //console.log(genero, Pelicula.listaGeneros.includes(genero));
        if (!Pelicula.listaGeneros.includes(genero)){
          console.error(`Género(s) incorrectos ${generos.join(", ")}`);
          Pelicula.generosAceptados();
        }
      }
    }
   }

   //Método .toFixed() indica el número de digitos luego del 
   //punto decimal. Debe ser en un rango entre 0 y -20.

   validarCalificacion(calificacion){
    if (this.validarNumero("Calificación", calificacion)) 
      return (calificacion < 0 || calificacion > 10)
      ? console.error("La calificación debe ser entre 0 y 10.")  
      : this.calificacion = calificacion.toFixed(1)
    }
// \n: Salto de Línea.
    fichaTecnica() {
      console.info(`Ficha Técnica: \nTitulo: "${this.titulo}"\nDirector: "${this.director}"\nAño: "${this.estreno}"\nPaís: "${this.pais.join(", ")}"\nGénero: "${this.generos.join(", ")}"\nCalificación: "${this.calificacion}"\nIMDB: "${this.id}"`)
    }
}


//Instanciamos los Géneros Aceptados:
//Pelicula.generosAceptados();

//Instanciamos la Clase Película:
  const peli = new Pelicula ({
   id:"jp8037675",
   titulo: "Título de la Película",
   director: "Acá va el Director de la Pelí",
   estreno: 2020,
   pais: ["Argentina", "Canadá" ],
   generos: ["Action", "Romance"],
   calificacion: 7.70
});

  peli.fichaTecnica();

// Creamos una variable que es un Arreglo:
//Con la ficha técnica de 3 películas.

const misPelis = [
  {
   id:"tt0092099",
   titulo: "Top Gun",
   director: "Tony Scott",
   estreno: 1986,
   pais: ["USA"],
   generos: ["Comedy", "Romance"],
   calificacion: 6.90
  },
  {
   id:"tt1745960",
   titulo: "Top Gun: Maverick",
   director: "Joseph Kosinski",
   estreno: 2022,
   pais: ["USA"],
   generos: ["Comedy", "Romance"],
   calificacion: 8.30
  },
  {
   id:"tt0091635",
   titulo: "9 1/2 semanas",
   director: "Adrian Lyne",
   estreno: 1986,
   pais: ["USA"],
   generos: ["Drama"],
   calificacion: 5.9
  }
];

/* Método .forEach() ejecuta la función indicada una vez 
por cada elemento del array. En este caso .forEach() por
cada objeto del Arreglo generará una nueva Instancia de
la CLASE PELÍCULA con "new Pelicula", ejecutamos e invocamos
FICHA TÉCNICA directamente.
*/

misPelis.forEach(element => new Pelicula(element).fichaTecnica());

    </script> 
 </body>
</html>